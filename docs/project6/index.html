<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 학습 가이드</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>

    <div class="container">
        <button id="menu-toggle">☰</button>
        <aside id="sidebar">
            <h2>목차</h2>
            <ul id="toc">
                <!-- Table of Contents will be generated here by JS -->
            </ul>
        </aside>

        <main id="presentation">
            <div id="slides-container">

                <!-- Slide 0: Title -->
                <section class="slide title-slide" id="title">
                    <div class="slide-content">
                        <h1>JavaScript 학습 가이드</h1>
                        <h2>웹 개발의 핵심 언어 마스터하기</h2>
                        <p style="margin-top: 50px;">사이드바 또는 키보드 방향키를 사용하여 탐색하세요.</p>
                    </div>
                </section>
                
                <!-- Slide 1: 01-tutorial 튜토리얼: 기본 문법 -->
                <section class="slide" id="tutorial-basic">
                    <div class="slide-content">
                        <h1>튜토리얼: 기본 문법</h1>
                        <h3>기본 규칙</h3>
                        <table>
                            <tr><th>규칙</th><th>설명</th><th>예제</th></tr>
                            <tr>
                                <td><strong>대소문자 구분</strong></td>
                                <td>모든 부분에서 대소문자를 구분함</td>
                                <td><code>function</code>과 <code>Function</code>은 다름</td>
                            </tr>
                            <tr>
                                <td><strong>세미콜론</strong></td>
                                <td>구문을 구분하는 구분자. 줄바꿈으로 대체 가능하지만 명시적 사용을 권장.</td>
                                <td><code>const a = 1;</code></td>
                            </tr>
                            <tr>
                                <td><strong>공백</strong></td>
                                <td>공백 수는 실행에 영향 없음 (가독성을 위해 사용)</td>
                                <td><code>const x = 1;</code></td>
                            </tr>
                        </table>
                        
                        <h3>주석 (Comment)</h3>
                        <pre><code class="language-javascript">
// 이것은 한 줄 주석입니다.

/*
이것은
여러 줄에 걸친
주석입니다.
*/
                        </code></pre>
                        
                        <h3>코드 실행 흐름</h3>
                        <p>JavaScript는 기본적으로 <strong>위에서 아래로 순차 실행</strong>되지만, 함수 호출이나 제어문을 만나면 실행 흐름이 변경됩니다.</p>
                        <pre><code class="language-javascript">
console.log('첫 번째'); // 1. 먼저 실행
console.log('두 번째'); // 2. 다음 실행
console.log('세 번째'); // 3. 마지막 실행
                        </code></pre>

                        <h3>표현식(Expression) vs 구문(Statement)</h3>
                        <table>
                            <tr><th>구분</th><th>설명</th><th>예제</th></tr>
                            <tr>
                                <td><strong>표현식</strong></td>
                                <td>값으로 평가되는 코드</td>
                                <td><code>1 + 2</code>, <code>'hello'</code>, <code>true</code></td>
                            </tr>
                            <tr>
                                <td><strong>구문</strong></td>
                                <td>실행 가능한 코드 단위</td>
                                <td><code>const x = 1;</code>, <code>if (true) {}</code></td>
                            </tr>
                        </table>

                        <h3>연산자 우선순위</h3>
                        <pre><code class="language-javascript">
// 곱셈이 덧셈보다 먼저 계산됨
1 + 2 * 3; // 7 (1 + 6)
(1 + 2) * 3; // 9 (3 * 3)

// 할당 연산자는 가장 낮은 우선순위
const result = 1 + 2 * 3; // result = 7
                        </code></pre>
                        
                        <h3>값(value)과 리터럴(literal)</h3>
                        <p>리터럴은 코드에 값을 직접 표현하는 방식입니다.</p>
                        <pre><code class="language-javascript">
1 // 정수 리터럴
2.5 // 부동소수점 실수 리터럴
'hello world' // 작은 따옴표 문자열 리터럴
"JavaScript" // 큰 따옴표 문자열 리터럴
true // 참(true)을 나타내는 진리값 리터럴
false // 거짓(false)을 나타내는 진리값 리터럴
null // '존재하지 않음'을 나타내는 값
undefined // '정의된 적 없음'을 나타내는 값
                        </code></pre>

                        <h3>실습 도구</h3>
                        <p><strong>REPL (Read-Evaluate-Print-Loop)</strong>을 사용하여 코드를 즉시 실행하고 결과를 확인할 수 있습니다.</p>
                        <ul>
                            <li>브라우저 개발자 도구 콘솔</li>
                            <li>온라인 REPL: <a href="https://repl.it/languages/babel" target="_blank">repl.it</a></li>
                            <li>Node.js 환경</li>
                        </ul>
                    </div>
                </section>
                
                <!-- Slide 2: 02-javascript-intro JavaScript 소개 -->
                <section class="slide" id="intro">
                    <div class="slide-content">
                        <h1>JavaScript 소개</h1>
                        <h3>JavaScript의 탄생과 역사</h3>
                        <table>
                            <tr>
                                <th>연도</th>
                                <th>사건</th>
                                <th>설명</th>
                            </tr>
                            <tr>
                                <td><strong>1995년</strong></td>
                                <td>JavaScript 탄생</td>
                                <td>Netscape Navigator에 최초 탑재</td>
                            </tr>
                            <tr>
                                <td><strong>1997년</strong></td>
                                <td>ECMAScript 표준 제정</td>
                                <td>ECMA에서 JavaScript 표준화</td>
                            </tr>
                            <tr>
                                <td><strong>1999년</strong></td>
                                <td>ES3 공개</td>
                                <td>브라우저 간 호환성 문제 시작</td>
                            </tr>
                            <tr>
                                <td><strong>2009년</strong></td>
                                <td>ES5 공개</td>
                                <td>브라우저 호환성 개선, 안정화</td>
                            </tr>
                            <tr>
                                <td><strong>마케팅</strong></td>
                                <td>Java와 유사한 이름</td>
                                <td>실제로는 Java와 다른 언어, "햄과 햄스터의 관계"</td>
                            </tr>
                        </table>

                        <h3>브라우저 호환성 문제</h3>
                        <p>초기 JavaScript는 브라우저마다 다른 기능을 제공하여 개발자들이 고생했습니다.</p>
                        <ul>
                            <li><strong>문제점</strong>: IE에서 작동하는 코드가 Firefox에서 작동하지 않음</li>
                            <li><strong>해결책</strong>: jQuery, Prototype 등 호환성 라이브러리 등장</li>
                            <li><strong>표준화</strong>: ECMAScript 표준을 따르는 브라우저 구현</li>
                        </ul>

                        <h3>언어 vs 구동 환경</h3>
                        <table>
                            <tr><th>구분</th><th>역할</th><th>예시</th></tr>
                            <tr>
                                <td><strong>JavaScript 언어</strong></td>
                                <td>코드 실행 관련 기능</td>
                                <td>변수, 함수, 객체 등</td>
                            </tr>
                            <tr>
                                <td><strong>구동 환경</strong></td>
                                <td>입출력 관련 기능</td>
                                <td>브라우저(alert), Node.js(fs), 게임 엔진</td>
                            </tr>
                        </table>
                        
                        <h3>ECMAScript와 브라우저 호환성</h3>
                        <p>JavaScript의 표준 명세를 <strong>ECMAScript</strong>라고 합니다. 브라우저 제조사들은 이 표준을 따라 기능을 구현합니다.</p>
                        <ul>
                            <li><strong>ES5 (2009)</strong>: 브라우저 호환성 개선</li>
                            <li><strong>ES2015 (ES6)</strong>: 클래스, 모듈, 화살표 함수 등 대규모 업데이트</li>
                            <li><strong>ES2016+</strong>: 매년 새로운 기능 추가</li>
                        </ul>
                        
                        <h3>트랜스파일러와 폴리필</h3>
                        <table>
                            <tr><th>도구</th><th>역할</th><th>예시</th></tr>
                            <tr>
                                <td><strong>트랜스파일러</strong></td>
                                <td>최신 문법을 구형 브라우저용 코드로 변환</td>
                                <td>Babel, TypeScript</td>
                            </tr>
                            <tr>
                                <td><strong>폴리필</strong></td>
                                <td>구형 브라우저에 없는 기능을 구현</td>
                                <td>Array.includes, Promise</td>
                            </tr>
                        </table>

                        <h3>폴리필 실제 예시</h3>
                        <pre><code class="language-javascript">
// Array.includes 폴리필 (IE에서 지원하지 않는 메서드)
if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement) {
    return this.indexOf(searchElement) !== -1;
  };
}

// 사용 예제
const numbers = [1, 2, 3];
console.log(numbers.includes(2)); // true (모든 브라우저에서 작동)
                        </code></pre>

                        <h3>현대 개발 환경</h3>
                        <p>오늘날 JavaScript 개발에서는 다음 도구들이 필수적으로 사용됩니다:</p>
                        <ul>
                            <li><strong>패키지 매니저</strong>: npm, yarn으로 라이브러리 관리</li>
                            <li><strong>번들러</strong>: Webpack, Vite로 코드 최적화</li>
                            <li><strong>린터</strong>: ESLint로 코드 품질 검사</li>
                            <li><strong>테스트</strong>: Jest, Mocha로 자동화된 테스트</li>
                        </ul>
                    </div>
                </section>
                
                <!-- Slide 3: 03-value-variable-type 튜토리얼: 변수와 타입 -->
                <section class="slide" id="tutorial-vars">
                    <div class="slide-content">
                        <h1>값, 변수, 타입</h1>
                        
                        <h3>값과 리터럴 (Value & Literal)</h3>
                        <p><strong>리터럴</strong>은 값의 표기법으로, 코드에서 값을 직접 표현하는 방식입니다.</p>
                        <pre><code class="language-javascript">
// 다양한 리터럴
1;              // 정수 리터럴
2.5;            // 부동 소수점 리터럴
'hello';        // 문자열 리터럴
true;           // 진리값 리터럴
null;           // null 리터럴
undefined;      // undefined 리터럴

// 리터럴과 연산자로 계산
1 + 2;          // 3
3 * 4;          // 12
'hello' + 'world';  // 'helloworld'
true || false;  // true
                        </code></pre>

                        <h3>변수 선언과 사용</h3>
                        <p>값에 이름을 붙여서 재사용할 수 있게 하는 기능입니다.</p>
                        <table>
                            <tr><th>키워드</th><th>재할당</th><th>선언 시 초기화</th><th>사용 시점</th></tr>
                            <tr><td><strong><code>const</code></strong></td><td>불가능</td><td>필수</td><td>기본 사용 (권장)</td></tr>
                            <tr><td><strong><code>let</code></strong></td><td>가능</td><td>선택</td><td>재할당이 필요한 경우만</td></tr>
                        </table>

                        <pre><code class="language-javascript">
// const: 재할당 불가능
const myConstant = 7;
// myConstant = 8; // TypeError: Assignment to constant variable.

// let: 재할당 가능
let seven = 7;
seven = 77;     // 재할당 가능
seven = 777;    // 또 다시 재할당 가능

// 선언만 하고 나중에 대입 (let만 가능)
let eight;
eight = 8;

// 한꺼번에 여러 변수 선언
let one = 1, two = 2, nothing;
const three = 3, four = 4;
                        </code></pre>

                        <h3>식별자 (Identifier) 명명 규칙</h3>
                        <table>
                            <tr><th>규칙</th><th>설명</th><th>예시</th></tr>
                            <tr><td><strong>사용 가능 문자</strong></td><td>숫자, 알파벳, $, _</td><td><code>foo, _bar123, $</code></td></tr>
                            <tr><td><strong>시작 문자</strong></td><td>숫자로 시작 불가</td><td><code>7seven</code> ❌</td></tr>
                            <tr><td><strong>예약어</strong></td><td>JavaScript 키워드 사용 불가</td><td><code>const, let, if</code> ❌</td></tr>
                            <tr><td><strong>재선언</strong></td><td>같은 이름 재선언 불가</td><td><code>let x; let x;</code> ❌</td></tr>
                        </table>

                        <h3>명명 관례 (Naming Convention)</h3>
                        <table>
                            <tr><th>방식</th><th>설명</th><th>예시</th><th>사용</th></tr>
                            <tr><td><strong>Camel Case</strong></td><td>단어 첫 글자 대문자</td><td><code>fastCampus, userName</code></td><td>JavaScript 표준</td></tr>
                            <tr><td><strong>Snake Case</strong></td><td>언더스코어로 단어 구분</td><td><code>fast_campus, user_name</code></td><td>Python 등에서 사용</td></tr>
                        </table>

                        <h3>const vs let 사용 원칙</h3>
                        <p><strong>항상 const 우선 사용!</strong> 의도치 않은 재할당을 방지할 수 있습니다.</p>
                        <pre><code class="language-javascript">
// 좋은 습관: const 우선 사용
const userName = '김개발';
const userAge = 28;
const isLoggedIn = true;

// let은 정말 재할당이 필요한 경우만
let score = 0;
for (let i = 0; i < 10; i++) {  // 루프 변수
    score += i;                  // 점수 누적
}
                        </code></pre>

                        <h3>타입 (Type) 확인</h3>
                        <p><code>typeof</code> 연산자로 값의 타입을 확인할 수 있습니다.</p>
                        <pre><code class="language-javascript">
// 기본 타입들
typeof 1;           // 'number'
typeof 'hello';     // 'string'
typeof true;        // 'boolean'
typeof undefined;   // 'undefined'
typeof null;        // 'object' (JavaScript의 유명한 버그)

// 참조 타입들
typeof {};          // 'object'
typeof [];          // 'object' 
typeof function(){}; // 'function'

// 주의: null의 typeof는 'object'입니다!
console.log(typeof null);  // 'object' (버그지만 호환성 위해 유지)
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 4: 04-number-type Number 타입 -->
                <section class="slide" id="number">
                    <div class="slide-content">
                        <h1>Number 타입</h1>
                        
                        <h3>number 타입 리터럴</h3>
                        <table>
                            <tr><th>타입</th><th>표기법</th><th>예시</th><th>설명</th></tr>
                            <tr><td><strong>정수</strong></td><td>그대로</td><td><code>7</code></td><td>정수 리터럴</td></tr>
                            <tr><td><strong>부동소수점</strong></td><td>소수점 포함</td><td><code>2.5</code></td><td>부동 소수점 리터럴</td></tr>
                            <tr><td><strong>2진수</strong></td><td><code>0b</code></td><td><code>0b111</code></td><td>2진수 리터럴</td></tr>
                            <tr><td><strong>8진수</strong></td><td><code>0o</code></td><td><code>0o777</code></td><td>8진수 리터럴</td></tr>
                            <tr><td><strong>16진수</strong></td><td><code>0x</code></td><td><code>0xf5</code></td><td>16진수 리터럴</td></tr>
                            <tr><td><strong>숫자 구분 기호</strong></td><td><code>_</code></td><td><code>10_000</code></td><td>가독성용 구분자 (ES2021)</td></tr>
                        </table>
                        
                        <h3>진법 리터럴의 동일성</h3>
                        <p>2진수, 8진수, 16진수는 표기법일 뿐, 내부적으로는 10진수와 동일합니다.</p>
                        <pre><code class="language-javascript">
0x4d === 77;      // true
0b1001101 === 77; // true
10_000 === 10000; // true
0b01010110_00111000; // 22072 (n진수에서도 사용 가능)
                        </code></pre>

                        <h3>산술 연산자와 우선순위</h3>
                        <table>
                            <tr><th>연산자</th><th>이름</th><th>예시</th></tr>
                            <tr><td><code>+</code></td><td>덧셈</td><td><code>1 + 2</code></td></tr>
                            <tr><td><code>-</code></td><td>뺄셈</td><td><code>3 - 4</code></td></tr>
                            <tr><td><code>*</code></td><td>곱셈</td><td><code>5 * 6</code></td></tr>
                            <tr><td><code>/</code></td><td>실수 나누기</td><td><code>7 / 8</code></td></tr>
                            <tr><td><code>%</code></td><td>나머지</td><td><code>14 % 3</code></td></tr>
                            <tr><td><code>**</code></td><td>거듭제곱</td><td><code>2 ** 3</code></td></tr>
                        </table>
                        <p><strong>연산자 우선순위:</strong> <code>**</code> → <code>*, /, %</code> → <code>+, -</code></p>
                        <pre><code class="language-javascript">
3 + 4 * 5; // 23 (4 * 5가 먼저 계산됨)
                        </code></pre>

                        <h3>정수/실수 판별</h3>
                        <p>JavaScript는 정수와 실수를 별도 타입으로 구분하지 않지만, 판별은 가능합니다.</p>
                        <pre><code class="language-javascript">
Number.isInteger(1);   // true
Number.isInteger(0.1); // false
                        </code></pre>

                        <h3>부동 소수점 (IEEE 754)과 오차</h3>
                        <p>컴퓨터는 <strong>IEEE 754 표준</strong>을 사용해 소수를 2진법으로 저장하므로 <strong>반올림 오차</strong>가 발생합니다.</p>
                        <pre><code class="language-javascript">
0.1 + 0.2; // 0.30000000000000004
0.1 + 0.2 === 0.3; // false

// 큰 정수에서도 오차 발생
10000000000000001 + 10000000000000002; // 20000000000000000
12345678901234567890; // 12345678901234567000
                        </code></pre>

                        <h3>BigInt (ES2020) - 큰 정수</h3>
                        <p>오차 없이 큰 정수를 다루려면 <strong>BigInt</strong>를 사용합니다.</p>
                        <pre><code class="language-javascript">
12345678901234567890n; // 12345678901234567890n
BigInt(12345678901234567890); // 12345678901234567890n

10000000000000001n + 10000000000000002n; // 20000000000000003n

typeof 10000n; // "bigint"
// 주의: number와 bigint는 연산 불가
10000 + 10000n; // TypeError: Cannot mix BigInt and other types
                        </code></pre>

                        <h3>특수한 number 값들</h3>
                        <table>
                            <tr><th>값</th><th>설명</th><th>발생 상황</th></tr>
                            <tr><td><code>NaN</code></td><td>Not a Number</td><td><code>0 / 0</code>, <code>1 * 'hello'</code></td></tr>
                            <tr><td><code>Infinity</code></td><td>양의 무한대</td><td><code>1 / 0</code></td></tr>
                            <tr><td><code>-Infinity</code></td><td>음의 무한대</td><td><code>1 / -0</code></td></tr>
                            <tr><td><code>-0</code></td><td>음의 영</td><td><code>1 * -0</code></td></tr>
                        </table>

                        <h3>NaN 주의사항</h3>
                        <p><strong>NaN은 자기 자신과 같지 않은 유일한 값</strong>입니다.</p>
                        <pre><code class="language-javascript">
const thisIsNan = NaN;
thisIsNan === NaN; // false ⚠️ 주의!

// 올바른 NaN 확인 방법
Number.isNaN(thisIsNan); // true
Object.is(thisIsNan, NaN); // true
                        </code></pre>

                        <h3>0과 -0의 차이</h3>
                        <pre><code class="language-javascript">
0 === -0; // true (거의 모든 경우에 같음)
Object.is(0, -0); // false (엄밀한 비교에서는 다름)

1 / 0;  // Infinity
1 / -0; // -Infinity
                        </code></pre>

                        <h3>Infinity 확인</h3>
                        <pre><code class="language-javascript">
Number.isFinite(1); // true
Number.isFinite(Infinity); // false
Number.isFinite('1'); // false (문자열은 변환하지 않음)

// 주의: 전역 isFinite는 문자열을 숫자로 변환함
isFinite('1'); // true
                        </code></pre>

                        <h3>문자열 → 숫자 변환</h3>
                        <table>
                            <tr><th>함수</th><th>설명</th><th>예시</th></tr>
                            <tr><td><code>parseInt()</code></td><td>정수로 변환</td><td><code>parseInt('123')</code> → <code>123</code></td></tr>
                            <tr><td><code>parseInt(str, radix)</code></td><td>n진수로 해석</td><td><code>parseInt('110', 2)</code> → <code>6</code></td></tr>
                            <tr><td><code>parseFloat()</code></td><td>부동소수점으로 변환</td><td><code>parseFloat('12.345')</code> → <code>12.345</code></td></tr>
                        </table>

                        <h3>⚠️ 다른 타입과의 연산 주의</h3>
                        <p><strong>number와 다른 타입 간 연산은 예측하기 어려운 결과</strong>를 낳으므로 피해야 합니다.</p>
                        <pre><code class="language-javascript">
1 + null;  // 1 
1 * '1';   // 1
1 + '1';   // '11' (문자열 연결)
1 - '1';   // 0

// 좋은 습관: 연산 전에 타입 확인 및 변환
const input = prompt('정수를 입력하세요');
const num = parseInt(input);
if (Number.isNaN(num)) {
  alert('정수가 아닙니다.');
} else {
  // 계산 수행
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 5: 05-string-type String 타입 -->
                <section class="slide" id="string">
                    <div class="slide-content">
                        <h1>String 타입</h1>
                        <h3>문자열 생성</h3>
                        <p>작은따옴표(<code>'</code>), 큰따옴표(<code>"</code>), 백틱(<code>`</code>)으로 문자열을 만들 수 있습니다.</p>
                        
                        <h3>템플릿 리터럴 (Template Literal)</h3>
                        <p>백틱(<code>`</code>)을 사용하여 문자열 내부에 변수나 표현식을 쉽게 삽입할 수 있습니다.</p>
                        <pre><code class="language-javascript">
const name = 'JavaScript';
const greeting = `Hello, ${name}!`; // "Hello, JavaScript!"

const multiLine = `이것은
여러 줄에 걸친
문자열입니다.`;
                        </code></pre>
                        
                        <h3>주요 메소드</h3>
                        <table>
                            <tr><th>메소드</th><th>설명</th><th>예제</th></tr>
                            <tr><td><code>.length</code></td><td>문자열 길이</td><td><code>'hello'.length // 5</code></td></tr>
                            <tr><td><code>.toUpperCase()</code></td><td>대문자로 변환</td><td><code>'js'.toUpperCase() // 'JS'</code></td></tr>
                            <tr><td><code>.toLowerCase()</code></td><td>소문자로 변환</td><td><code>'JS'.toLowerCase() // 'js'</code></td></tr>
                            <tr><td><code>.includes('sub')</code></td><td>부분 문자열 포함 여부</td><td><code>'abc'.includes('b') // true</code></td></tr>
                            <tr><td><code>.slice(start, end)</code></td><td>문자열 자르기</td><td><code>'abcde'.slice(1, 3) // 'bc'</code></td></tr>
                            <tr><td><code>.replace('a', 'b')</code></td><td>문자열 치환 (첫 번째)</td><td><code>'hello'.replace('l', 'x') // 'hexlo'</code></td></tr>
                            <tr><td><code>.split('sep')</code></td><td>문자열을 배열로 분리</td><td><code>'a,b,c'.split(',') // ['a', 'b', 'c']</code></td></tr>
                            <tr><td><code>.trim()</code></td><td>양쪽 공백 제거</td><td><code>'  hi  '.trim() // 'hi'</code></td></tr>
                        </table>
                    </div>
                </section>

                <!-- Slide 6: 06-boolean-type Boolean 타입 -->
                <section class="slide" id="boolean">
                    <div class="slide-content">
                        <h1>Boolean 타입</h1>
                        <p>참(<code>true</code>) 또는 거짓(<code>false</code>)을 나타내는 타입입니다.</p>
                        
                        <h3>논리 연산자</h3>
                        <table>
                            <tr><th>연산자</th><th>이름</th><th>설명</th><th>예제</th></tr>
                            <tr><td><strong><code>&&</code></strong></td><td>논리곱 (AND)</td><td>모두 참일 때만 참</td><td><code>true && false // false</code></td></tr>
                            <tr><td><strong><code>||</code></strong></td><td>논리합 (OR)</td><td>하나라도 참이면 참</td><td><code>true || false // true</code></td></tr>
                            <tr><td><strong><code>!</code></strong></td><td>논리부정 (NOT)</td><td>참과 거짓을 뒤바꿈</td><td><code>!true // false</code></td></tr>
                        </table>
                        
                        <h3>Truthy와 Falsy</h3>
                        <p>JavaScript에서는 <code>if</code>문 등에서 불린 값이 아니더라도 참 또는 거짓으로 평가될 수 있습니다.</p>
                        
                        <h4>Falsy (거짓으로 취급되는 값)</h4>
                        <ul>
                            <li><code>false</code></li>
                            <li><code>0</code>, <code>-0</code>, <code>0n</code></li>
                            <li><code>""</code> (빈 문자열)</li>
                            <li><code>null</code></li>
                            <li><code>undefined</code></li>
                            <li><code>NaN</code></li>
                        </ul>
                        <p><strong>이 외의 모든 값은 Truthy(참으로 취급)입니다.</strong> (예: <code>[]</code>, <code>{}</code>, <code>'false'</code>)</p>
                        
                        <h3>단축 평가 (Short-circuit Evaluation)</h3>
                        <p>논리 연산은 왼쪽부터 평가하며, 결과가 확정되면 오른쪽은 평가하지 않습니다.</p>
                        <pre><code class="language-javascript">
// user가 존재할 때만 user.name을 출력
user && console.log(user.name);

// name이 falsy(빈 문자열 등)일 경우 'Guest'를 할당
const displayName = name || 'Guest';
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 7: 07-null-undefined null과 undefined -->
                <section class="slide" id="null-undefined">
                    <div class="slide-content">
                        <h1>null과 undefined</h1>
                        <p>두 값 모두 '값이 없음'을 나타내지만, 미묘한 차이가 있습니다.</p>
                        
                        <h3>undefined</h3>
                        <ul>
                            <li>시스템이 자동으로 부여하는 값</li>
                            <li>변수를 선언만 하고 값을 할당하지 않은 경우</li>
                            <li>객체에 존재하지 않는 속성에 접근하려는 경우</li>
                            <li>함수가 아무것도 반환하지 않을 때</li>
                        </ul>
                        <pre><code class="language-javascript">
let a;
console.log(a); // undefined

const obj = {};
console.log(obj.nonExistent); // undefined
                        </code></pre>
                        
                        <h3>null</h3>
                        <ul>
                            <li>개발자가 의도적으로 '값이 없음'을 명시할 때 사용</li>
                            <li>'비어있는 객체'를 의도적으로 나타낼 때 주로 사용</li>
                        </ul>
                        <pre><code class="language-javascript">
let b = null;
console.log(b); // null
                        </code></pre>

                        <h3>비교와 Null Check</h3>
                        <table>
                            <tr><th>비교</th><th>결과</th><th>설명</th></tr>
                            <tr><td><code>null == undefined</code></td><td><code>true</code></td><td>동등 연산자(<code>==</code>)는 타입을 변환하여 비교하므로 같다고 판단.</td></tr>
                            <tr><td><code>null === undefined</code></td><td><code>false</code></td><td>일치 연산자(<code>===</code>)는 타입까지 비교하므로 다르다고 판단.</td></tr>
                        </table>
                        
                        <p>값이 <code>null</code> 또는 <code>undefined</code> 인지 확인할 때 (Null Check) <code>==</code> 연산자가 유용하게 쓰일 수 있습니다.</p>
                        <pre><code class="language-javascript">
function printValue(value) {
  // value가 null이거나 undefined가 아닐 때만 출력
  if (value != null) {
    console.log(value);
  }
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 8: 08-function 함수 -->
                <section class="slide" id="function">
                    <div class="slide-content">
                        <h1>함수</h1>
                        
                        <h3>함수란?</h3>
                        <p><strong>큰 프로그램을 잘게 쪼개어 특정 코드 뭉치를 반복해서 사용할 수 있도록 묶어놓은 코드 뭉치의 단위</strong>입니다.</p>
                        <ul>
                            <li>코드의 재사용성과 유지보수성 향상</li>
                            <li>복잡한 문제를 작은 단위로 분해</li>
                            <li>JavaScript 함수는 매우 강력한 기능 제공</li>
                        </ul>

                        <h3>함수의 구성 요소</h3>
                        <p>함수는 <strong>이름</strong>, <strong>매개변수</strong>, <strong>반환값</strong>으로 구성됩니다.</p>
                        <pre><code class="language-javascript">
// 함수 정의
function add(x, y) {       // add: 함수 이름, x,y: 매개변수(parameter)
  const result = x + y;
  return result;           // 반환값(return value)
}

// 함수 호출
add(2, 3);                 // 2, 3: 인수(argument), 결과: 5
                        </code></pre>

                        <h3>함수 실행 순서</h3>
                        <p>함수 호출 시 실행 흐름이 함수 내부로 이동하고, 반환 후 원래 위치로 돌아갑니다.</p>
                        <pre><code class="language-javascript">
// 1 - 함수 정의
function add(x, y) {
  return x + y;            // 3 - 함수 실행
}

// 2 - 함수 호출
const result = add(2, 3);  
// 4 - 나머지 코드 실행
console.log(result);       // 5

// 주의: 함수 정의만으로는 내부 코드가 실행되지 않음!
                        </code></pre>

                        <h3>매개변수와 인수</h3>
                        <p>매개변수는 <strong>독립적인 변수</strong>로, 함수 외부 변수와는 별개입니다.</p>
                        <pre><code class="language-javascript">
function reassign(x) {
  x = 2;                   // 매개변수 x에 새 값 할당
  return x;
}

const y = 1;
const result = reassign(y); // y를 인수로 전달

console.log(y);            // 1 (원본 변수 y는 변경되지 않음)
console.log(result);       // 2 (함수 내부에서 변경된 값)
                        </code></pre>

                        <h3>반환값 (Return Value)</h3>
                        <p><code>return</code> 구문은 함수의 결과를 결정하고 함수 실행을 즉시 종료합니다.</p>
                        <pre><code class="language-javascript">
function add(x, y) {
  return x + y;
  console.log('이 부분은 실행되지 않습니다.'); // return 후 코드는 실행 안됨
}

// return이 없거나 값이 없으면 undefined 반환
function returnUndefined() {
  return; // undefined 반환
}

function noReturn() {
  // return 없음 → undefined 반환
}

console.log(returnUndefined()); // undefined
console.log(noReturn());        // undefined
                        </code></pre>
                        <h3>스코프 (Scope)</h3>
                        <p>변수가 유효한 코드상의 <strong>유효 범위</strong>입니다. 매개변수는 함수 스코프를 가집니다.</p>
                        <pre><code class="language-javascript">
function add(x, y) {       // x, y는 함수 내부에서만 유효
  return x + y;
}

add(2, 3);
// console.log(x);         // ReferenceError: x is not defined
                        </code></pre>

                        <h3>스코프 연쇄 (Scope Chain)</h3>
                        <p>함수 내부에서 바깥 스코프의 변수에 접근할 수 있습니다.</p>
                        <pre><code class="language-javascript">
const five = 5;            // 전역 스코프

function add5(x) {
  return x + five;         // 바깥 스코프의 five 변수 접근
}

add5(3);                   // 8

// 중첩 함수에서도 가능
function outer() {
  const outerVar = 'outer';
  
  function inner() {
    const innerVar = 'inner';
    console.log(outerVar);  // 바깥 함수의 변수 접근 가능
  }
  
  inner();
  // console.log(innerVar); // Error: inner 변수는 접근 불가
}
                        </code></pre>

                        <h3>변수 가리기 (Variable Shadowing)</h3>
                        <p>안쪽 스코프에서 같은 이름의 변수를 재정의하면 바깥쪽 변수가 가려집니다.</p>
                        <pre><code class="language-javascript">
const x = 3;               // 전역 x

function add5(x) {         // 매개변수 x (전역 x를 가림)
  function add(x, y) {     // 또 다른 매개변수 x (위의 x를 가림)
    return x + y;          // 가장 가까운 x 사용
  }
  return add(x, 5);
}

add5(x);                   // 각 스코프에서 해당하는 x 사용
                        </code></pre>

                        <h3>어휘적 스코핑 (Lexical Scoping)</h3>
                        <p>스코프는 <strong>코드가 작성된 구조</strong>에 의해 결정되며, 함수 호출 형태에 의해 결정되지 않습니다.</p>
                        <pre><code class="language-javascript">
function add5(x) {
  const five = 5;
  return add(x);           // add 함수 호출
}

function add(x) {
  return five + x;         // ReferenceError: five is not defined
}
// add 함수는 add5 내부에서 호출되지만, five 변수에 접근할 수 없음

// 올바른 방법: 함수를 내부에 정의
function add5Correct(x) {
  const five = 5;
  function add(x) {        // add5 내부에 정의
    return five + x;       // 이제 five에 접근 가능
  }
  return add(x);
}
                        </code></pre>

                        <h3>값으로서의 함수 (1급 함수)</h3>
                        <p>JavaScript에서 함수는 <strong>값</strong>이므로 변수에 저장하거나 다른 함수에 전달할 수 있습니다.</p>
                        <pre><code class="language-javascript">
function add(x, y) {
  return x + y;
}

// 함수를 변수에 대입
const plus = add;
plus(1, 2);                // 3

// 함수를 배열/객체에 저장
[add];
{addFunc: add};

// 함수를 인수로 전달 (고차 함수)
function isEven(x) {
  return x % 2 === 0;
}
[1, 2, 3, 4, 5].filter(isEven); // [2, 4]

// 함수에서 함수 반환
function createEmptyFunc() {
  function func() {}
  return func;
}
                        </code></pre>

                        <h3>익명 함수 (Anonymous Function)</h3>
                        <p>이름이 없는 함수로, 주로 다른 함수의 인수로 전달할 때 사용합니다.</p>
                        <pre><code class="language-javascript">
// 익명 함수를 변수에 저장
const add = function(x, y) {
  return x + y;
};

// 익명 함수를 인수로 전달
[1, 2, 3, 4, 5].filter(function (x) {
  return x % 2 === 0;
});                        // [2, 4]
                        </code></pre>

                        <h3>화살표 함수 (Arrow Function)</h3>
                        <p>ES2015에서 도입된 간결한 함수 표기법입니다.</p>
                        <pre><code class="language-javascript">
// 기본 화살표 함수
const add = (x, y) => x + y;        // 바로 반환

// 중괄호 사용 시 명시적 return 필요
const add2 = (x, y) => {
  const result = x + y;
  return result;
};

// 매개변수가 하나면 괄호 생략 가능
const negate = x => !x;

// 익명 함수 대신 화살표 함수 사용 (간결함)
[1, 2, 3, 4, 5].filter(x => x % 2 === 0); // [2, 4]
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 9: 09-control-statement 제어 구문 -->
                <section class="slide" id="control-statement">
                    <div class="slide-content">
                        <h1>제어 구문</h1>
                        
                        <h3>조건문 (Conditional Statement)</h3>
                        <p>프로그램의 여러 **경우의 수**를 처리하기 위해 사용합니다.</p>
                        <ul>
                            <li>사용자 입력에 따른 다른 동작</li>
                            <li>상황에 따른 프로그램 로직 분기</li>
                            <li>예외 상황 처리</li>
                        </ul>

                        <h3>if...else 구문</h3>
                        <p>조건에 따라 코드를 실행하거나 실행하지 않습니다.</p>
                        <pre><code class="language-javascript">
function game() {
  const result = Math.ceil(Math.random() * 6); // 주사위 굴리기
  
  if (result >= 4) {
    alert('당신이 이겼습니다!');
  } else {
    alert('당신이 졌습니다.');
  }
}

// else 생략 가능
if (result === 6) {
  alert('당신은 운이 좋군요!');
}

// 중괄호 생략 (구문이 하나일 때)
if (result === 6) alert('당신은 운이 좋군요!');
                        </code></pre>

                        <h3>if...else 구문의 중첩</h3>
                        <p>세 개 이상의 경우의 수를 표현할 때 사용합니다.</p>
                        <pre><code class="language-javascript">
// 다중 조건 처리
if (result >= 5) {
  alert('당신이 이겼습니다!');
} else if (result >= 3) {
  alert('비겼습니다.');
} else {
  alert('당신이 졌습니다.');
}

// 색상 변환 함수 예제
function translateColor(english) {
  if (english === 'red') {
    return '빨강색';
  } else if (english === 'blue') {
    return '파랑색';
  } else if (english === 'purple' || english === 'violet') {
    return '보라색';
  } else {
    return '일치하는 색깔이 없습니다.';
  }
}
                        </code></pre>

                        <h3>switch 구문</h3>
                        <p>하나의 변수에 대해 많은 경우의 수가 있을 때 사용합니다.</p>
                        <pre><code class="language-javascript">
function translateColor(english) {
  let result;
  switch (english) {
    case 'red':
      result = '빨강색';
      break;
    case 'blue':
      result = '파랑색';
      break;
    case 'purple':
    case 'violet':  // fall-through 활용
      result = '보라색';
      break;
    default:
      result = '일치하는 색깔이 없습니다.';
  }
  return result;
}
                        </code></pre>

                        <h3>⚠️ switch 구문 주의사항</h3>
                        <p><strong>break를 빠뜨리면 다음 case가 연이어 실행</strong>됩니다. (fall-through)</p>
                        <ul>
                            <li>각 case 마지막에 <code>break</code> 필수</li>
                            <li>일치 여부는 <code>===</code> 연산자와 동일</li>
                            <li>fall-through 특성을 활용한 코드 단축 가능</li>
                        </ul>

                        <h3>반복문 (Looping Statement)</h3>
                        <p>유사한 작업을 여러 번 반복할 때 사용합니다. **루프(Loop)**라고도 합니다.</p>
                        <ul>
                            <li>배열의 모든 요소 처리</li>
                            <li>사용자 입력 반복 받기</li>
                            <li>데이터 가공 작업 반복</li>
                        </ul>

                        <h3>while 구문</h3>
                        <p>특정 조건을 만족하는 동안 코드를 반복 실행합니다.</p>
                        <pre><code class="language-javascript">
let i = 0; // 초기값

while (i < 5) { // 실행 조건
  console.log(`현재 i의 값: ${i}`);
  i++; // 갱신
}

console.log('루프가 종료되었습니다.');
                        </code></pre>

                        <h3>do...while 구문</h3>
                        <p><strong>내부 코드를 무조건 한 번은 실행</strong>한 후 조건을 검사합니다.</p>
                        <pre><code class="language-javascript">
do {
  console.log('최소 한 번은 실행됩니다!');
} while (false); // 조건이 false여도 1회 실행
                        </code></pre>

                        <h3>for 구문</h3>
                        <p>초기값, 조건, 갱신을 한 곳에 모아 작성하는 반복문입니다.</p>
                        <pre><code class="language-javascript">
// for (초기값 정의; 실행 조건; 갱신) { ... }
for (let i = 0; i < 5; i++) {
  console.log(`현재 i의 값: ${i}`);
}

// 배열 순회 (전통적 방법)
const arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
  console.log(`배열의 ${i + 1}번째 요소는 ${arr[i]} 입니다.`);
}
                        </code></pre>

                        <h3>배열 순회 - 현대적 방법</h3>
                        <p>ES2015 이후로는 더 간편한 방법들을 주로 사용합니다.</p>
                        <pre><code class="language-javascript">
const arr = [1, 2, 3, 4, 5];

// forEach 메소드 (함수형)
arr.forEach((item, index) => {
  console.log(`배열의 ${index + 1}번째 요소는 ${item} 입니다.`);
});

// for...of 구문 (요소 중심)
for (let item of arr) {
  console.log(`현재 요소는 ${item} 입니다.`);
}
                        </code></pre>

                        <h3>break와 continue</h3>
                        <table>
                            <tr><th>키워드</th><th>기능</th><th>사용 시점</th></tr>
                            <tr><td><code>break</code></td><td>루프 완전 종료</td><td>특정 조건에서 루프를 빠져나가고 싶을 때</td></tr>
                            <tr><td><code>continue</code></td><td>현재 반복 건너뛰기</td><td>특정 조건의 요소만 제외하고 계속 진행할 때</td></tr>
                        </table>
                        <pre><code class="language-javascript">
// break 예제 - 퀴즈 게임
while (true) {
  const answer = prompt('빨강의 보색은?');
  if (answer === '초록') {
    alert('정답입니다! 🎉');
    break; // 루프 완전 종료
  } else {
    alert('틀렸습니다! 다시 시도해보세요.');
  }
}

// continue 예제 - 7의 배수만 출력
for (let i = 1; i < 100; i++) {
  if (i % 7 !== 0) {
    continue; // 7의 배수가 아니면 건너뛰기
  }
  console.log(`${i}는 7의 배수입니다.`);
}
                        </code></pre>

                        <h3>함수 즉시 종료: return과 throw</h3>
                        <table>
                            <tr><th>키워드</th><th>기능</th><th>사용 시점</th></tr>
                            <tr><td><code>return</code></td><td>값을 반환하며 함수 종료</td><td>정상적인 함수 완료</td></tr>
                            <tr><td><code>throw</code></td><td>에러를 발생시키며 함수 종료</td><td>예외 상황 처리</td></tr>
                        </table>
                        <pre><code class="language-javascript">
// return으로 간결한 switch 작성
function translateColor(english) {
  switch (english) {
    case 'red': return '빨강색';
    case 'blue': return '파랑색';
    case 'purple':
    case 'violet': return '보라색';
    default: return '일치하는 색깔이 없습니다.';
  }
}

// throw로 에러 처리
function translateColor(english) {
  switch (english) {
    case 'red': return '빨강색';
    case 'blue': return '파랑색';
    case 'purple':
    case 'violet': return '보라색';
    default: throw new Error('일치하는 색깔이 없습니다.');
  }
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 10: 10-object 객체 -->
                <section class="slide" id="object">
                    <div class="slide-content">
                        <h1>객체</h1>
                        
                        <h3>객체란?</h3>
                        <p>JavaScript의 **핵심 자료형**으로, **많은 기능**을 내장한 **통(container)** 같은 **자료구조**입니다.</p>
                        <ul>
                            <li>여러 값을 한 번에 담을 수 있음</li>
                            <li><strong>이름-값 쌍(name-value pair)</strong>으로 구성</li>
                            <li>이름-값 쌍을 **속성(property)**이라고 함</li>
                        </ul>

                        <h3>객체 리터럴 (Object Literal)</h3>
                        <p>중괄호 <code>{}</code> 안에 직접 이름-값 쌍을 적어 객체를 생성합니다.</p>
                        <pre><code class="language-javascript">
const person = {
  name: '윤아준',        // 속성 이름: 'name', 속성 값: '윤아준'
  age: 19,              // 속성 이름: 'age', 속성 값: 19
  'languages': ['Korean', 'English'], // 문자열로 속성 이름 지정
  '한국 나이': 20        // 공백 포함시 문자열 표기 필수
};
                        </code></pre>

                        <h3>속성 이름 단축 표기법</h3>
                        <p>이미 정의된 변수명과 속성명이 같을 때 단축 표기가 가능합니다.</p>
                        <pre><code class="language-javascript">
const name = '윤아준';
const age = 19;

// 기본 표기법
const person1 = {
  name: name,
  age: age
};

// 단축 표기법 (ES2015+)
const person2 = {
  name,  // name: name과 동일
  age    // age: age와 동일
};

// 계산된 속성 이름
const propName = 'favoriteColor';
const person3 = {
  [propName]: 'blue'  // favoriteColor: 'blue'와 동일
};
                        </code></pre>

                        <h3>속성 접근자 (Property Accessor)</h3>
                        <table>
                            <tr><th>방법</th><th>문법</th><th>사용 시점</th></tr>
                            <tr>
                                <td><strong>점 표기법</strong></td>
                                <td><code>obj.propertyName</code></td>
                                <td>일반적인 경우 (권장)</td>
                            </tr>
                            <tr>
                                <td><strong>대괄호 표기법</strong></td>
                                <td><code>obj['propertyName']</code></td>
                                <td>공백, 특수문자 포함시 필수</td>
                            </tr>
                        </table>
                        <pre><code class="language-javascript">
const person = {};

// 점 표기법
person.name = '윤아준';
person.age = 19;

// 대괄호 표기법 (공백 포함 속성명)
person['한국 나이'] = 20;
                        </code></pre>

                        <h3>객체 다루기</h3>
                        <pre><code class="language-javascript">
const person = {
  name: '윤아준',
  age: 19,
  languages: ['Korean', 'English']
};

// 속성 읽기
person.name;         // '윤아준'
person.age;          // 19
person.languages[0]; // 'Korean'

// 속성 쓰기
person.name = '신하경';
person.age = 20;

// 새 속성 추가
person.address = '서울특별시 강남구 신사동';

// 속성 삭제
delete person.address;

// 속성 존재 확인
'name' in person;        // true
'phoneNumber' in person; // false
                        </code></pre>

                        <h3>메소드 (Method)</h3>
                        <p>객체의 속성값으로 **함수**를 지정한 것을 **메소드**라고 합니다.</p>
                        <pre><code class="language-javascript">
// 기본 메소드 정의
const person1 = {
  greet: function() {
    return 'hello';
  }
};

// ES2015+ 단축 문법
const person2 = {
  greet() {
    return 'hello';
  }
};

person1.greet(); // 'hello'
person2.greet(); // 'hello'
                        </code></pre>

                        <h3>this 키워드</h3>
                        <p>메소드 내부에서 <code>this</code>는 해당 메소드를 갖고 있는 **객체**를 가리킵니다.</p>
                        <pre><code class="language-javascript">
const person = {
  name: '윤아준',
  age: 19,
  introduce() {
    // this로 객체 속성 접근
    return `안녕하세요, 제 이름은 ${this.name}입니다. 제 나이는 ${this.age}살 입니다.`;
  },
  getOlder() {
    // this로 객체 속성 갱신
    this.age++;
  }
};

person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 19살 입니다.'
person.getOlder();
person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 20살 입니다.'
                        </code></pre>

                        <h3>⚠️ this의 동적 바인딩</h3>
                        <p><code>this</code>는 메소드가 **어떻게 호출되는가**에 따라 달라집니다.</p>
                        <pre><code class="language-javascript">
function introduce() {
  return `안녕하세요, 제 이름은 ${this.name}입니다.`;
}

const person1 = { name: '윤아준', introduce };
const person2 = { name: '신하경', introduce };

person1.introduce(); // 안녕하세요, 제 이름은 윤아준입니다.
person2.introduce(); // 안녕하세요, 제 이름은 신하경입니다.

// 같은 함수지만 호출 컨텍스트에 따라 this가 달라짐
                        </code></pre>

                        <h3>프로토타입 (Prototype)</h3>
                        <p>객체 간에 **공유되는 속성과 메소드**를 효율적으로 저장하는 JavaScript의 핵심 기능입니다.</p>
                        <pre><code class="language-javascript">
// 문제: 메소드가 객체마다 중복 생성됨
function personFactory(name) {
  return {
    name,
    introduce: function() {  // 매번 새 함수 생성
      return `안녕하세요, 제 이름은 ${this.name}입니다.`;
    }
  };
}

// 해결: 프로토타입으로 메소드 공유
const personPrototype = {
  introduce: function() {
    return `안녕하세요, 제 이름은 ${this.name}입니다.`;
  }
};

const person1 = Object.create(personPrototype);
person1.name = '윤아준';

const person2 = Object.create(personPrototype);
person2.name = '신하경';

person1.introduce === person2.introduce; // true (같은 함수 공유)
                        </code></pre>

                        <h3>프로토타입 체인 (Prototype Chain)</h3>
                        <p>속성에 접근할 때 현재 객체 → 프로토타입 → 프로토타입의 프로토타입... 순으로 탐색합니다.</p>
                        <pre><code class="language-javascript">
const obj1 = { a: 1 };
const obj2 = { b: 2 };
const obj3 = { c: 3 };

// obj3 -> obj2 -> obj1 체인 구성
Object.setPrototypeOf(obj2, obj1);
Object.setPrototypeOf(obj3, obj2);

console.log(obj3.c); // 3 (obj3에서 발견)
console.log(obj3.b); // 2 (obj3의 프로토타입에서 발견)
console.log(obj3.a); // 1 (obj3의 프로토타입의 프로토타입에서 발견)

// 프로토타입 체인 확인
obj1.isPrototypeOf(obj3); // true
obj2.isPrototypeOf(obj3); // true
                        </code></pre>

                        <h3>생성자 (Constructor)와 new</h3>
                        <p><code>new</code> 키워드와 함께 사용하는 함수를 **생성자**라고 합니다.</p>
                        <pre><code class="language-javascript">
// 생성자 정의 (관례적으로 대문자로 시작)
function Person(name) {
  this.name = name;  // 새로 만들어질 객체의 속성 지정
}

// 프로토타입에 메소드 추가
Person.prototype.introduce = function() {
  return `안녕하세요, 제 이름은 ${this.name}입니다.`;
};

// 객체 생성
const person = new Person('윤아준');
person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다.'

// 인스턴스 확인
person instanceof Person; // true
person.constructor === Person; // true
                        </code></pre>

                        <h3>정적 메소드 (Static Method)</h3>
                        <p>생성자 함수 자체에 정의된 메소드로, 인스턴스가 아닌 **생성자를 통해 호출**합니다.</p>
                        <pre><code class="language-javascript">
// 정적 메소드 정의
Person.compareAge = function(person1, person2) {
  if (person1.age < person2.age) {
    return '첫 번째 사람의 나이가 더 적습니다.';
  } else if (person1.age === person2.age) {
    return '두 사람의 나이가 같습니다.';
  } else {
    return '두 번째 사람의 나이가 더 적습니다.';
  }
};

// 정적 메소드 사용 (생성자를 통해 호출)
Person.compareAge(person1, person2);

// 예: 내장 정적 메소드들
Number.isNaN(NaN);       // true
Object.getPrototypeOf(obj);
Array.isArray([]);       // true
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 11: 11-array 배열 -->
                <section class="slide" id="array">
                    <div class="slide-content">
                        <h1>배열</h1>
                        
                        <h3>배열의 특징</h3>
                        <p>JavaScript에 내장된 자료구조로, 순서가 있는 데이터를 저장합니다.</p>
                        <ul>
                            <li>배열도 객체의 일종 (<code>typeof [] === 'object'</code>)</li>
                            <li>요소(element)들 간에는 <strong>순서</strong>가 있음</li>
                            <li><code>Array.prototype</code>의 다양한 메소드 제공</li>
                            <li>프로토타입으로 <code>Array.prototype</code> 객체가 지정됨</li>
                        </ul>

                        <h3>배열 생성하기</h3>
                        <pre><code class="language-javascript">
// 1. 배열 리터럴 (가장 권장)
const empty = [];                     // 빈 배열
const numbers = [1, 2, 3];           // 숫자 배열  
const strings = ['one', 'two', 'three']; // 문자열 배열
const objects = [{prop: 1}, {prop: 2}]; // 객체 배열
const mixed = [1, 'one', {prop: 1}, null]; // 혼합 배열

// 2. Array 생성자 (비일관적 동작 - 주의!)
new Array(1);           // [empty] (길이 1인 빈 배열)
new Array(1000);        // [empty × 1000] (길이 1000인 빈 배열)
new Array(1, 2, 3);     // [1, 2, 3] (요소들로 구성)

// 3. Array.of (일관된 동작 - 권장)
Array.of(1, 2, 3);      // [1, 2, 3]
Array.of(1);            // [1] (길이가 아닌 요소로 취급)

// 4. Array.from (유사 배열 객체나 iterable을 배열로 변환)
Array.from('hello');    // ['h', 'e', 'l', 'l', 'o']
                        </code></pre>

                        <h3>요소 접근과 수정</h3>
                        <p><strong>인덱스</strong>(0부터 시작하는 정수)를 사용해 배열 요소에 접근합니다.</p>
                        <pre><code class="language-javascript">
const arr = ['one', 'two', 'three'];

// 요소 읽기 (대괄호 표기법)
arr[0];                 // 'one' (첫 번째 요소)
arr[1];                 // 'two' (두 번째 요소)  
arr[2];                 // 'three' (세 번째 요소)
arr[3];                 // undefined (존재하지 않는 인덱스)

// 요소 수정
const arr2 = [false, false, false];
arr2[1] = true;
console.log(arr2);      // [false, true, false]

// fill 메소드로 한번에 여러 요소 변경
const arr3 = [1, 2, 3, 4, 5];
arr3.fill(0);           // [0, 0, 0, 0, 0] (전체를 0으로)
arr3.fill(1, 2, 4);     // [0, 0, 1, 1, 0] (인덱스 2~3만 1로)
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 11-2: 배열 메소드 - 요소 추가/제거 -->
                <section class="slide" id="array-methods">
                    <div class="slide-content">
                        <h1>배열 요소 추가/제거</h1>
                        
                        <h3>배열 끝에서 추가/제거 (Stack 방식)</h3>
                        <table>
                            <tr><th>메소드</th><th>동작</th><th>반환값</th><th>시간복잡도</th></tr>
                            <tr><td><code>push(...items)</code></td><td>끝에 요소 추가</td><td>새로운 배열 길이</td><td>O(1)</td></tr>
                            <tr><td><code>pop()</code></td><td>끝 요소 제거</td><td>제거된 요소</td><td>O(1)</td></tr>
                        </table>
                        <pre><code class="language-javascript">
const arr = [];
arr.push('one');           // 1 (새 길이 반환)
arr.push('two', 'three');  // 3 (여러 요소 한번에 추가)
console.log(arr);          // ['one', 'two', 'three']

const popped = arr.pop();  // 'three' (제거된 요소 반환)
console.log(arr);          // ['one', 'two']
console.log(popped);       // 'three'

// 빈 배열에서 pop 시도
[].pop();                  // undefined
                        </code></pre>

                        <h3>배열 시작에서 추가/제거 (Queue 방식)</h3>
                        <table>
                            <tr><th>메소드</th><th>동작</th><th>반환값</th><th>시간복잡도</th></tr>
                            <tr><td><code>unshift(...items)</code></td><td>앞에 요소 추가</td><td>새로운 배열 길이</td><td>O(n)</td></tr>
                            <tr><td><code>shift()</code></td><td>첫 요소 제거</td><td>제거된 요소</td><td>O(n)</td></tr>
                        </table>
                        <pre><code class="language-javascript">
const arr = [];
arr.unshift(1);            // 1
arr.unshift(2, 3);         // 3 (앞에 여러 요소 추가)
console.log(arr);          // [2, 3, 1]

const shifted = arr.shift(); // 2 (첫 요소 제거 및 반환)
console.log(arr);          // [3, 1]
console.log(shifted);      // 2

// 빈 배열에서 shift 시도
[].shift();                // undefined
                        </code></pre>

                        <h3>splice - 배열 중간 위치 조작</h3>
                        <p><code>splice(start, deleteCount, ...items)</code>는 배열의 임의 위치에서 요소를 제거하고 새 요소를 삽입합니다.</p>
                        <pre><code class="language-javascript">
let arr = [1, 2, 3, 4, 5];

// 인덱스 1부터 3개 요소를 새 요소들로 교체
const removed = arr.splice(1, 3, 'two', 'three', 'four');
console.log(removed);      // [2, 3, 4] (제거된 요소들 배열로 반환)
console.log(arr);          // [1, 'two', 'three', 'four', 5]

// 요소 제거만 (deleteCount만 지정)
const arr2 = [1, 2, 3, 4, 5];
arr2.splice(1, 3);         // [2, 3, 4] 제거
console.log(arr2);         // [1, 5]

// 요소 삽입만 (deleteCount를 0으로)
const arr3 = [1, 5];
arr3.splice(1, 0, 2, 3, 4); // 인덱스 1에 2,3,4 삽입
console.log(arr3);         // [1, 2, 3, 4, 5]
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 11-3: 배열 메소드 - 정렬과 순회 -->
                <section class="slide" id="array-sort-iteration">
                    <div class="slide-content">
                        <h1>배열 정렬과 순회</h1>
                        
                        <h3>배열 뒤집기와 정렬</h3>
                        <pre><code class="language-javascript">
// reverse - 배열 순서 뒤집기 (원본 수정)
const arr = [1, 2, 3, 4, 5];
const result = arr.reverse(); // [5, 4, 3, 2, 1]
console.log(arr);           // [5, 4, 3, 2, 1] (원본도 변경됨)
console.log(result === arr); // true (같은 배열 반환)

// sort - 배열 정렬 (원본 수정)
const numbers = [3, 1, 4, 1, 5, 9];

// ⚠️ 비교 함수 없으면 문자열로 변환 후 사전순 정렬!
numbers.sort();             // [1, 1, 3, 4, 5, 9] (우연히 올바름)
[20, 3, 100].sort();        // [100, 20, 3] (잘못된 결과!)

// 올바른 숫자 정렬 (비교 함수 필수)
numbers.sort((x, y) => x - y); // [1, 1, 3, 4, 5, 9] (오름차순)
numbers.sort((x, y) => y - x); // [9, 5, 4, 3, 1, 1] (내림차순)

// 문자열 길이로 정렬
const names = ['Alice', 'Bob', 'Charlie', 'David'];
names.sort((x, y) => x.length - y.length);
// ['Bob', 'Alice', 'David', 'Charlie'] (길이 순)

// 객체 배열 정렬
const people = [{name: 'Alice', age: 30}, {name: 'Bob', age: 25}];
people.sort((x, y) => x.age - y.age); // 나이순 정렬
                        </code></pre>

                        <h3>배열 순회 방법들</h3>
                        <p>각 상황에 맞는 최적의 순회 방법을 선택하세요.</p>
                        <pre><code class="language-javascript">
const arr = [1, 2, 3, 4, 5];

// 1. for...of 구문 (가장 권장 - 간결하고 성능 좋음)
for (const item of arr) {
  console.log(item);        // 값만 필요한 경우
}

// 2. forEach 메소드 (인덱스나 배열 자체가 필요한 경우)
arr.forEach((item, index, array) => {
  console.log(`${index}: ${item}`); // 인덱스와 함께 출력
  // break, continue 사용 불가 (함수이므로)
});

// 3. 전통적인 for 루프 (성능이 매우 중요하거나 break 필요한 경우)
for (let i = 0; i < arr.length; i++) {
  if (arr[i] === 3) break;  // 조건에 따른 중단 가능
  console.log(arr[i]);
}

// 4. for...in 구문 (배열에는 권장하지 않음)
for (const index in arr) {
  console.log(arr[index]);  // 인덱스를 문자열로 받음
  // 배열이 아닌 속성도 순회할 수 있어 위험
}
                        </code></pre>

                        <h3>성능 비교 및 권장 사항</h3>
                        <table>
                            <tr><th>방법</th><th>성능</th><th>사용 시기</th><th>특징</th></tr>
                            <tr><td><code>for...of</code></td><td>빠름</td><td>값만 필요할 때</td><td>가장 권장</td></tr>
                            <tr><td><code>forEach</code></td><td>중간</td><td>인덱스 필요할 때</td><td>함수형 스타일</td></tr>
                            <tr><td><code>for</code></td><td>가장 빠름</td><td>성능 중요할 때</td><td>중단 가능</td></tr>
                            <tr><td><code>for...in</code></td><td>느림</td><td>사용 금지</td><td>배열에 부적합</td></tr>
                        </table>
                    </div>
                </section>

                <!-- Slide 12: 12-value-in-depth 값 더 알아보기 -->
                <section class="slide" id="value-in-depth">
                    <div class="slide-content">
                        <h1>값 더 알아보기</h1>
                        <h3>let, const와 블록 스코프</h3>
                        <table>
                            <tr><th>특징</th><th>let/const</th><th>var</th></tr>
                            <tr><td><strong>재선언</strong></td><td>불허</td><td>허용</td></tr>
                            <tr><td><strong>호이스팅</strong></td><td>선언 전 사용 불가</td><td>undefined로 초기화</td></tr>
                            <tr><td><strong>스코프</strong></td><td>블록 스코프</td><td>함수 스코프</td></tr>
                        </table>
                        
                        <h3>참조 (Reference)</h3>
                        <pre><code class="language-javascript">
// 원시 타입: 값 자체가 복사됨
let a = 1;
let b = a;
a = 2;
console.log(b); // 1 (변경되지 않음)

// 참조 타입: 참조(주소)가 복사됨
let obj1 = { prop: 1 };
let obj2 = obj1;
obj1.prop = 2;
console.log(obj2.prop); // 2 (함께 변경됨)
                        </code></pre>
                        
                        <h3>스코프 체인</h3>
                        <p>안쪽 스코프에서 바깥쪽 스코프의 변수에 접근 가능하지만, 반대는 불가능합니다.</p>
                        <pre><code class="language-javascript">
let global = 'global';

function outer() {
  let outerVar = 'outer';
  
  function inner() {
    let innerVar = 'inner';
    console.log(global, outerVar, innerVar); // 모두 접근 가능
  }
  
  inner();
}
                        </code></pre>
                        
                        <h3>변수 사용 권장사항</h3>
                        <ol>
                            <li><strong>const 우선 사용</strong>: 재대입이 필요 없을 때</li>
                            <li><strong>let 차선 사용</strong>: 재대입이 필요할 때</li>
                            <li><strong>var 사용 금지</strong>: 예상치 못한 동작 가능성</li>
                        </ol>
                    </div>
                </section>

                <!-- Slide 13: 13-function-in-depth 함수 더 알아보기 -->
                <section class="slide" id="function-in-depth">
                    <div class="slide-content">
                        <h1>함수 더 알아보기</h1>
                        <h3>함수 정의 방법</h3>
                        <table>
                            <tr><th>방법</th><th>문법</th><th>특징</th></tr>
                            <tr><td><strong>함수 선언문</strong></td><td><code>function add() {}</code></td><td>호이스팅 됨</td></tr>
                            <tr><td><strong>함수 표현식</strong></td><td><code>const add = function() {}</code></td><td>호이스팅 안됨</td></tr>
                            <tr><td><strong>화살표 함수</strong></td><td><code>const add = () => {}</code></td><td>this 바인딩 없음</td></tr>
                        </table>
                        
                        <h3>클로저 (Closure)</h3>
                        <p>함수와 그 함수가 선언된 렉시컬 환경의 조합입니다.</p>
                        <pre><code class="language-javascript">
function createCounter() {
  let count = 0;
  
  return {
    increment() {
      count++;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.getCount()); // 1
                        </code></pre>
                        
                        <h3>arguments 객체와 나머지 매개변수</h3>
                        <pre><code class="language-javascript">
// 구식 방법: arguments 객체 (권장하지 않음)
function oldSum() {
  let result = 0;
  for (let i = 0; i < arguments.length; i++) {
    result += arguments[i];
  }
  return result;
}

// 현대적 방법: 나머지 매개변수 (권장)
function newSum(...numbers) {
  return numbers.reduce((sum, num) => sum + num, 0);
}

console.log(newSum(1, 2, 3, 4)); // 10
                        </code></pre>

                        <h3>this 바인딩과 조작 메서드</h3>
                        <pre><code class="language-javascript">
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: 'Alice' };

// call: 즉시 호출하면서 this 변경
console.log(greet.call(person, 'Hello', '!')); // "Hello, Alice!"

// apply: 배열로 인수 전달
console.log(greet.apply(person, ['Hi', '?'])); // "Hi, Alice?"

// bind: 새로운 함수 생성 (this 고정)
const boundGreet = greet.bind(person);
console.log(boundGreet('Hey', '.')); // "Hey, Alice."
                        </code></pre>
                        
                        <h3>화살표 함수 vs 일반 함수</h3>
                        <table>
                            <tr><th>특징</th><th>일반 함수</th><th>화살표 함수</th></tr>
                            <tr><td><strong>this 바인딩</strong></td><td>호출 방식에 따라 변경</td><td>정의된 위치의 this 사용</td></tr>
                            <tr><td><strong>arguments</strong></td><td>사용 가능</td><td>사용 불가 (나머지 매개변수 사용)</td></tr>
                            <tr><td><strong>생성자</strong></td><td>new 키워드로 호출 가능</td><td>생성자로 사용 불가</td></tr>
                            <tr><td><strong>호이스팅</strong></td><td>함수 선언문은 호이스팅</td><td>호이스팅 안됨</td></tr>
                        </table>

                        <h3>함수형 프로그래밍: 고차 함수</h3>
                        <p>함수를 인수로 받거나 함수를 반환하는 함수입니다.</p>
                        <pre><code class="language-javascript">
// 함수를 반환하는 함수
function createValidator(minLength) {
  return function(str) {
    return str.length >= minLength;
  };
}

const isValidPassword = createValidator(8);
console.log(isValidPassword('12345')); // false
console.log(isValidPassword('password123')); // true

// 함수를 인수로 받는 함수
function processArray(arr, processor) {
  return arr.map(processor);
}

const numbers = [1, 2, 3, 4];
const doubled = processArray(numbers, x => x * 2); // [2, 4, 6, 8]
                        </code></pre>

                        <h3>익명 함수와 즉시 실행 함수</h3>
                        <pre><code class="language-javascript">
// 익명 함수 (콜백으로 자주 사용)
setTimeout(function() {
  console.log('3초 후 실행');
}, 3000);

// 즉시 실행 함수 표현식 (IIFE)
(function() {
  const privateVar = '외부에서 접근 불가';
  console.log('즉시 실행!');
})();

// 화살표 함수로 IIFE
(() => {
  console.log('화살표 함수 IIFE');
})();
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 14: 14-object-in-depth 객체 더 알아보기 -->
                <section class="slide" id="object-in-depth">
                    <div class="slide-content">
                        <h1>객체 더 알아보기</h1>
                        
                        <h3>객체 자신의 속성 vs 상속받은 속성</h3>
                        <p><strong>Own Property</strong>와 <strong>Inherited Property</strong>를 구분하는 방법입니다.</p>
                        <pre><code class="language-javascript">
// 프로토타입으로부터 상속받은 속성과 자신의 속성
const obj = Object.create({inheritedProp: 'inherited'});
obj.ownProp = 'own';

console.log(obj.inheritedProp);        // 'inherited'
console.log(obj.ownProp);              // 'own'

// in 연산자는 상속받은 속성도 true 반환
console.log('inheritedProp' in obj);   // true
console.log('ownProp' in obj);         // true

// hasOwnProperty는 객체 자신의 속성만 true 반환
console.log(obj.hasOwnProperty('inheritedProp')); // false
console.log(obj.hasOwnProperty('ownProp'));       // true
                        </code></pre>

                        <h3>속성 기술자 (Property Descriptor)</h3>
                        <p>각 속성은 <strong>부수속성(Property Attribute)</strong>을 가지며, 이것이 속성의 동작을 결정합니다.</p>
                        <pre><code class="language-javascript">
const obj = {prop: 1};

// 속성 기술자 확인
Object.getOwnPropertyDescriptor(obj, 'prop');
// { value: 1, writable: true, enumerable: true, configurable: true }

// Math.PI의 속성 기술자
Object.getOwnPropertyDescriptor(Math, 'PI');
// { value: 3.141592653589793, writable: false, enumerable: false, configurable: false }

// Math.PI는 삭제되지 않음 (configurable: false)
delete Math.PI;             // false
Math.PI;                    // 3.141592653589793

// Math.PI는 변경되지 않음 (writable: false)
Math.PI = 10;               // 무시됨
Math.PI;                    // 3.141592653589793
                        </code></pre>

                        <h3>데이터 속성의 부수속성 4가지</h3>
                        <table>
                            <tr><th>부수속성</th><th>설명</th><th>기본값</th></tr>
                            <tr><td><code>value</code></td><td>속성에 저장된 값</td><td>undefined</td></tr>
                            <tr><td><code>writable</code></td><td>값 변경 가능 여부</td><td>true</td></tr>
                            <tr><td><code>enumerable</code></td><td>열거 가능 여부</td><td>true</td></tr>
                            <tr><td><code>configurable</code></td><td>삭제/수정 가능 여부</td><td>true</td></tr>
                        </table>
                    </div>
                </section>

                <!-- Slide 14-2: 속성 정의와 접근자 속성 -->
                <section class="slide" id="object-property-definition">
                    <div class="slide-content">
                        <h1>속성 정의와 접근자 속성</h1>
                        
                        <h3>속성 기술자로 속성 정의하기</h3>
                        <pre><code class="language-javascript">
// Object.create의 두 번째 인수로 속성 기술자 전달
const obj = Object.create(Object.prototype, {
  prop: {
    value: 1,
    writable: false,       // 변경 불가
    enumerable: true,      // 열거 가능
    configurable: false    // 삭제/수정 불가
  },
  another: {
    value: 2               // 나머지는 false로 기본 설정
  }
});

obj.prop = 2;              // 무시됨 (writable: false)
console.log(obj.prop);     // 1

// Object.defineProperty로 기존 객체에 속성 정의
Object.defineProperty(obj, 'newProp', {
  value: 3,
  writable: true,
  enumerable: false,       // for...in, Object.keys에서 제외
  configurable: true
});
                        </code></pre>

                        <h3>접근자 속성 (Accessor Property)</h3>
                        <p><strong>Getter</strong>와 <strong>Setter</strong>를 통해 속성의 읽기/쓰기 동작을 제어할 수 있습니다.</p>
                        <pre><code class="language-javascript">
// 환전 기능이 있는 Money 객체
function Money(won = 0) {
  this._won = won; // 내부 값 저장
}

// 접근자 속성 정의
Object.defineProperties(Money.prototype, {
  won: {
    get: function() {
      return this._won;
    },
    set: function(amount) {
      this._won = amount;
    }
  },
  dollar: {
    get: function() {
      return this._won / 1300; // 원 → 달러 변환
    },
    set: function(amount) {
      this._won = amount * 1300; // 달러 → 원 변환
    }
  }
});

const money = new Money(1300);
console.log(money.dollar);    // 1 (자동 환전)

money.dollar = 2;             // 달러로 설정
console.log(money.won);       // 2600 (자동으로 원화로 변환)
                        </code></pre>

                        <h3>객체 리터럴에서 접근자 속성</h3>
                        <pre><code class="language-javascript">
const obj = {
  _hidden: 0,

  // getter 메소드
  get prop() {
    console.log('getter 호출됨');
    return this._hidden;
  },

  // setter 메소드  
  set prop(value) {
    console.log('setter 호출됨');
    this._hidden = value;
  }
};

obj.prop = 42;        // setter 호출됨
console.log(obj.prop); // getter 호출됨, 42

// 접근자 속성의 속성 기술자
Object.getOwnPropertyDescriptor(obj, 'prop');
// { get: [Function: get], set: [Function: set], enumerable: true, configurable: true }
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 14-3: 객체 복사와 불변성 -->
                <section class="slide" id="object-copy-immutability">
                    <div class="slide-content">
                        <h1>객체 복사와 불변성</h1>
                        
                        <h3>객체 속성 열거 방법들</h3>
                        <table>
                            <tr><th>메소드</th><th>대상</th><th>열거 불가능한 속성</th><th>상속받은 속성</th></tr>
                            <tr><td><code>Object.keys</code></td><td>자신의 열거 가능한 속성</td><td>❌</td><td>❌</td></tr>
                            <tr><td><code>Object.values</code></td><td>자신의 열거 가능한 속성 값</td><td>❌</td><td>❌</td></tr>
                            <tr><td><code>Object.entries</code></td><td>자신의 열거 가능한 [키, 값]</td><td>❌</td><td>❌</td></tr>
                            <tr><td><code>Object.getOwnPropertyNames</code></td><td>자신의 모든 속성</td><td>✅</td><td>❌</td></tr>
                            <tr><td><code>for...in</code></td><td>열거 가능한 모든 속성</td><td>❌</td><td>✅</td></tr>
                        </table>
                        
                        <h3>얕은 복사 (Shallow Copy)</h3>
                        <p><code>Object.assign</code>은 열거 가능한 속성들을 대상 객체에 복사합니다.</p>
                        <pre><code class="language-javascript">
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };

// 빈 객체를 대상으로 여러 객체 병합
const merged = Object.assign({}, obj1, obj2);
console.log(merged);      // { a: 1, b: 3, c: 4 }

// 객체 복제 (얕은 복사)
const original = { a: 1, b: { nested: 2 } };
const copy = Object.assign({}, original);

// 중첩된 객체는 참조가 복사됨
console.log(copy.b === original.b);  // true (같은 객체 참조)

original.b.nested = 999;
console.log(copy.b.nested);         // 999 (원본 변경이 복사본에 영향)
                        </code></pre>

                        <h3>깊은 복사 문제와 해결책</h3>
                        <pre><code class="language-javascript">
// 얕은 복사의 문제점
const original = {
  user: { name: 'Alice', age: 30 },
  items: [1, 2, 3]
};

const shallowCopy = Object.assign({}, original);
shallowCopy.user.name = 'Bob';        // 원본도 변경됨!
console.log(original.user.name);     // 'Bob'

// 간단한 깊은 복사 (제한적)
const deepCopy = JSON.parse(JSON.stringify(original));
// ⚠️ 함수, undefined, Symbol, Date 등은 제대로 복사되지 않음

// 실제 프로젝트에서는 lodash.cloneDeep 등의 라이브러리 사용 권장
// const deepCopy = _.cloneDeep(original);
                        </code></pre>

                        <h3>객체 불변성 제어</h3>
                        <table>
                            <tr><th>메소드</th><th>속성 추가</th><th>속성 수정</th><th>속성 삭제</th><th>설명</th></tr>
                            <tr><td><code>Object.preventExtensions</code></td><td>❌</td><td>✅</td><td>✅</td><td>확장 금지</td></tr>
                            <tr><td><code>Object.seal</code></td><td>❌</td><td>✅</td><td>❌</td><td>밀봉</td></tr>
                            <tr><td><code>Object.freeze</code></td><td>❌</td><td>❌</td><td>❌</td><td>동결</td></tr>
                        </table>
                        <pre><code class="language-javascript">
const obj = { a: 1, b: 2 };

// 객체 동결 (가장 강한 제한)
Object.freeze(obj);

obj.a = 999;              // 무시됨
obj.c = 3;                // 무시됨  
delete obj.b;             // 무시됨

console.log(obj);         // { a: 1, b: 2 } (변경되지 않음)

// 동결 상태 확인
Object.isFrozen(obj);     // true
Object.isSealed(obj);     // true
Object.isExtensible(obj); // false
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 15: 15-operator-in-depth 연산자 심화 -->
                <section class="slide" id="operator-in-depth">
                    <div class="slide-content">
                        <h1>연산자 심화</h1>
                        <h3>단축 평가 (Short-circuit Evaluation)</h3>
                        <p>논리 연산자들은 양쪽 피연산자를 모두 평가하지 않아도 결과를 결정할 수 있는 경우, 불필요한 평가를 생략합니다.</p>
                        <table>
                            <tr><th>연산자</th><th>동작</th><th>예제</th></tr>
                            <tr><td><code>&&</code></td><td>왼쪽이 falsy면 왼쪽 값 반환, 아니면 오른쪽 값 반환</td><td><code>false && expression</code></td></tr>
                            <tr><td><code>||</code></td><td>왼쪽이 truthy면 왼쪽 값 반환, 아니면 오른쪽 값 반환</td><td><code>true || expression</code></td></tr>
                            <tr><td><code>??</code></td><td>왼쪽이 null/undefined가 아니면 왼쪽 값 반환</td><td><code>null ?? 'default'</code></td></tr>
                        </table>
                        
                        <h3>실용적인 활용 예제</h3>
                        <pre><code class="language-javascript">
// if문을 대신하는 단축 평가
user && console.log(user.name);

// 기본값 설정
const displayName = name || 'Guest';
const username = user?.name ?? 'Anonymous';

// 옵셔널 체이닝 (ES2020)
const address = user?.profile?.address?.street;
                        </code></pre>
                        
                        <h3>Optional Chaining (?.) 연산자</h3>
                        <p>중첩된 객체의 속성에 안전하게 접근할 수 있게 해주는 ES2020 문법입니다.</p>
                        <pre><code class="language-javascript">
const person = {
  name: '김개발',
  company: {
    name: 'Tech Corp'
    // office 정보가 없음
  }
};

// 안전한 접근 (에러 없이 undefined 반환)
const officeAddress = person.company?.office?.address;
console.log(officeAddress); // undefined

// 기본값과 함께 사용
const address = person.company?.office?.address ?? '주소 정보 없음';
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 16: 16-builtins 내장 객체 -->
                <section class="slide" id="builtins">
                    <div class="slide-content">
                        <h1>내장 객체</h1>
                        <h3>Object 정적 메서드</h3>
                        <table>
                            <tr><th>메서드</th><th>설명</th><th>예제</th></tr>
                            <tr><td><code>Object.keys()</code></td><td>객체의 키들을 배열로 반환</td><td><code>Object.keys({a: 1, b: 2}) // ['a', 'b']</code></td></tr>
                            <tr><td><code>Object.values()</code></td><td>객체의 값들을 배열로 반환</td><td><code>Object.values({a: 1, b: 2}) // [1, 2]</code></td></tr>
                            <tr><td><code>Object.entries()</code></td><td>키-값 쌍을 배열로 반환</td><td><code>Object.entries({a: 1}) // [['a', 1]]</code></td></tr>
                            <tr><td><code>Object.assign()</code></td><td>객체 병합</td><td><code>Object.assign({}, a, b)</code></td></tr>
                        </table>
                        
                        <h3>Array 정적 메서드</h3>
                        <pre><code class="language-javascript">
// Array.from(): 유사 배열을 실제 배열로 변환
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
const realArray = Array.from(arrayLike);
console.log(realArray); // ['a', 'b']

// Array.isArray(): 배열 여부 확인
Array.isArray([1, 2, 3]); // true
Array.isArray('hello'); // false

// Array.of(): 인수들로 배열 생성
Array.of(1, 2, 3); // [1, 2, 3]
                        </code></pre>
                        
                        <h3>Date 객체</h3>
                        <pre><code class="language-javascript">
// 현재 날짜와 시간
const now = new Date();

// 특정 날짜 생성
const birthday = new Date('1990-01-01');
const specificDate = new Date(2023, 11, 25); // 2023년 12월 25일

// 날짜 메서드
now.getFullYear(); // 연도
now.getMonth(); // 월 (0부터 시작)
now.getDate(); // 일
now.getDay(); // 요일 (0: 일요일)
                        </code></pre>
                        
                        <h3>Math 객체</h3>
                        <pre><code class="language-javascript">
Math.PI; // 3.141592653589793
Math.abs(-5); // 5 (절댓값)
Math.round(4.7); // 5 (반올림)
Math.floor(4.7); // 4 (내림)
Math.ceil(4.2); // 5 (올림)
Math.max(1, 3, 2); // 3
Math.min(1, 3, 2); // 1
Math.random(); // 0과 1 사이의 랜덤 수

// 1-10 사이 랜덤 정수
Math.floor(Math.random() * 10) + 1;
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 17: 17-fp 함수형 프로그래밍 -->
                <section class="slide" id="functional-programming">
                    <div class="slide-content">
                        <h1>함수형 프로그래밍</h1>
                        <h3>함수형 프로그래밍 원칙</h3>
                        <ul>
                            <li><strong>순수 함수</strong>: 같은 입력에 대해 항상 같은 출력, 부작용 없음</li>
                            <li><strong>불변성</strong>: 데이터를 변경하지 않고 새로운 데이터 생성</li>
                            <li><strong>고차 함수</strong>: 함수를 인자로 받거나 함수를 반환하는 함수</li>
                        </ul>
                        
                        <h3>순수 함수 예제</h3>
                        <pre><code class="language-javascript">
// 순수 함수 (Pure Function)
function add(a, b) {
  return a + b; // 항상 같은 입력에 같은 출력
}

// 비순수 함수 (Impure Function)
let counter = 0;
function incrementCounter() {
  counter++; // 외부 상태 변경 (부작용)
  return counter;
}
                        </code></pre>
                        
                        <h3>배열 고차 함수 활용</h3>
                        <pre><code class="language-javascript">
const numbers = [1, 2, 3, 4, 5];

// 함수형 스타일의 데이터 처리
const result = numbers
  .filter(n => n % 2 === 0)    // 짝수만 필터링
  .map(n => n * 2)             // 각 요소에 2를 곱함
  .reduce((sum, n) => sum + n, 0); // 합계 계산

console.log(result); // 12 (2*2 + 4*2 = 4 + 8 = 12)
                        </code></pre>
                        
                        <h3>커링 (Currying)</h3>
                        <p>여러 인자를 받는 함수를 하나의 인자만 받는 함수의 연속으로 변환하는 기법입니다.</p>
                        <pre><code class="language-javascript">
// 일반 함수
function multiply(a, b, c) {
  return a * b * c;
}

// 커링된 함수
function curriedMultiply(a) {
  return function(b) {
    return function(c) {
      return a * b * c;
    };
  };
}

// 화살표 함수로 더 간단하게
const curriedMultiplyArrow = a => b => c => a * b * c;

// 사용
const multiplyBy2 = curriedMultiplyArrow(2);
const multiplyBy2And3 = multiplyBy2(3);
console.log(multiplyBy2And3(4)); // 24
                        </code></pre>
                        
                        <h3>실전 함수형 프로그래밍 패턴</h3>
                        <pre><code class="language-javascript">
// 실제 데이터 처리 예제
const students = [
  { name: '김철수', score: 85, subject: 'math' },
  { name: '이영희', score: 92, subject: 'english' },
  { name: '박민수', score: 78, subject: 'math' },
  { name: '최지원', score: 96, subject: 'english' }
];

// 함수형 스타일로 데이터 분석
const mathTopStudents = students
  .filter(student => student.subject === 'math')
  .filter(student => student.score >= 80)
  .map(student => ({ ...student, grade: 'A' }))
  .sort((a, b) => b.score - a.score);

console.log(mathTopStudents);
// [{ name: '김철수', score: 85, subject: 'math', grade: 'A' }]
                        </code></pre>

                        <h3>메모이제이션 (Memoization)</h3>
                        <p>계산 결과를 캐시하여 성능을 최적화하는 기법입니다.</p>
                        <pre><code class="language-javascript">
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('캐시에서 반환:', key);
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    console.log('새로 계산:', key);
    return result;
  };
}

// 피보나치 수열 (메모이제이션 적용)
const fibonacci = memoize(function(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(10)); // 새로 계산하며 결과 출력
console.log(fibonacci(10)); // 캐시에서 즉시 반환
                        </code></pre>

                        <h3>함수 조합과 파이프라인</h3>
                        <pre><code class="language-javascript">
// 함수 조합
const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);

// 파이프라인 (왼쪽에서 오른쪽으로)
const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);

// 유틸리티 함수들
const trim = str => str.trim();
const toLowerCase = str => str.toLowerCase();
const removeSpaces = str => str.replace(/\s+/g, '');
const addPrefix = prefix => str => prefix + str;

// 파이프라인으로 문자열 처리
const processUserName = pipe(
  trim,
  toLowerCase,
  removeSpaces,
  addPrefix('user_')
);

console.log(processUserName('  John Doe  ')); // "user_johndoe"
                        </code></pre>

                        <h3>함수형 vs 명령형 스타일 비교</h3>
                        <pre><code class="language-javascript">
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 명령형 스타일 (How - 어떻게)
function imperativeProcessing(nums) {
  let result = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 === 0) {
      result.push(nums[i] * nums[i]);
    }
  }
  return result;
}

// 함수형 스타일 (What - 무엇을)
const functionalProcessing = nums => nums
  .filter(n => n % 2 === 0)    // 짝수만
  .map(n => n * n);            // 제곱

console.log(imperativeProcessing(numbers));  // [4, 16, 36, 64, 100]
console.log(functionalProcessing(numbers));  // [4, 16, 36, 64, 100]
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 18: 18-iteration 이터레이션 -->
                <section class="slide" id="iteration">
                    <div class="slide-content">
                        <h1>이터레이션</h1>
                        <h3>이터러블 (Iterable)과 이터레이터 (Iterator)</h3>
                        <ul>
                            <li><strong>이터러블</strong>: Symbol.iterator 메서드를 가진 객체</li>
                            <li><strong>이터레이터</strong>: next() 메서드를 가진 객체</li>
                        </ul>
                        
                        <h3>for...of 반복문</h3>
                        <p>이터러블 객체의 요소들을 순회합니다.</p>
                        <pre><code class="language-javascript">
// 배열 순회
const arr = [1, 2, 3];
for (const item of arr) {
  console.log(item); // 1, 2, 3
}

// 문자열 순회
const str = 'hello';
for (const char of str) {
  console.log(char); // 'h', 'e', 'l', 'l', 'o'
}

// Map 순회
const map = new Map([['a', 1], ['b', 2]]);
for (const [key, value] of map) {
  console.log(key, value); // 'a' 1, 'b' 2
}
                        </code></pre>
                        
                        <h3>제너레이터 (Generator)</h3>
                        <p>함수의 실행을 중간에 멈췄다가 재개할 수 있는 특별한 함수입니다.</p>
                        <pre><code class="language-javascript">
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

// for...of로 사용
for (const num of numberGenerator()) {
  console.log(num); // 1, 2, 3
}
                        </code></pre>
                        
                        <h3>무한 시퀀스 생성</h3>
                        <pre><code class="language-javascript">
function* infiniteNumbers() {
  let i = 0;
  while (true) {
    yield i++;
  }
}

const numbers = infiniteNumbers();
console.log(numbers.next().value); // 0
console.log(numbers.next().value); // 1
console.log(numbers.next().value); // 2

// 피보나치 수열 생성기
function* fibonacci() {
  let a = 0, b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fib = fibonacci();
for (let i = 0; i < 10; i++) {
  console.log(fib.next().value);
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 19: 19-class 클래스 -->
                <section class="slide" id="classes">
                    <div class="slide-content">
                        <h1>클래스</h1>
                        <h3>클래스 vs 프로토타입</h3>
                        <p>ES2015 클래스는 기존 프로토타입 기반 상속의 문법적 설탕(syntactic sugar)입니다.</p>
                        <table>
                            <tr><th>방식</th><th>문법</th><th>특징</th></tr>
                            <tr><td><strong>프로토타입</strong></td><td>function + prototype</td><td>JavaScript 원래 방식</td></tr>
                            <tr><td><strong>클래스</strong></td><td>class 키워드</td><td>더 깔끔하고 이해하기 쉬움</td></tr>
                        </table>

                        <h3>클래스 기본 문법</h3>
                        <pre><code class="language-javascript">
class Person {
  // 생성자: 인스턴스 생성 시 호출
  constructor(name, age) {
    this.name = name;     // 인스턴스 속성
    this.age = age;
  }
  
  // 인스턴스 메서드 (Person.prototype에 저장됨)
  greet() {
    return `안녕하세요, ${this.name}입니다.`;
  }
  
  // getter: 속성처럼 접근 가능
  get info() {
    return `${this.name} (${this.age}세)`;
  }
  
  // setter: 값 할당 시 검증 로직 추가 가능
  set age(newAge) {
    if (newAge < 0) {
      throw new Error('나이는 0 이상이어야 합니다.');
    }
    this._age = newAge;
  }
  
  // 정적 메서드: 클래스 자체에 속함 (인스턴스 없이 호출)
  static compare(person1, person2) {
    return person1.age - person2.age;
  }
  
  // 정적 속성
  static species = 'Homo sapiens';
}

// 사용 예제
const alice = new Person('Alice', 30);
console.log(alice.greet());        // "안녕하세요, Alice입니다."
console.log(alice.info);           // "Alice (30세)"
console.log(Person.species);       // "Homo sapiens"
console.log(Person.compare(alice, new Person('Bob', 25))); // 5
                        </code></pre>
                        
                        <h3>상속 (Inheritance)</h3>
                        <p><strong>extends</strong> 키워드로 부모 클래스의 기능을 상속받아 확장할 수 있습니다.</p>
                        <pre><code class="language-javascript">
class Student extends Person {
  constructor(name, age, school) {
    // super(): 부모 생성자 호출 (반드시 this 사용 전에 호출)
    super(name, age);
    this.school = school;
    this.subjects = [];
  }
  
  // 새로운 메서드 추가
  study(subject) {
    console.log(`${this.name}이(가) ${subject}를 공부하고 있습니다.`);
    this.subjects.push(subject);
  }
  
  // 메서드 오버라이딩 (부모 메서드 재정의)
  greet() {
    // super.methodName(): 부모 메서드 호출
    const parentGreeting = super.greet(); 
    return `${parentGreeting} 저는 ${this.school} 학생입니다.`;
  }
  
  // getter 오버라이딩
  get info() {
    const parentInfo = super.info;
    return `${parentInfo}, ${this.school} 재학`;
  }
}

// 다중 레벨 상속
class GraduateStudent extends Student {
  constructor(name, age, school, thesis) {
    super(name, age, school);
    this.thesis = thesis;
  }
  
  research() {
    console.log(`${this.name}이(가) "${this.thesis}" 주제로 연구하고 있습니다.`);
  }
  
  greet() {
    const studentGreeting = super.greet();
    return `${studentGreeting} 대학원생입니다.`;
  }
}

// 사용 예제
const bob = new Student('Bob', 20, '서울대학교');
console.log(bob.greet()); // "안녕하세요, Bob입니다. 저는 서울대학교 학생입니다."
bob.study('수학');        // "Bob이(가) 수학를 공부하고 있습니다."

const carol = new GraduateStudent('Carol', 25, 'MIT', 'AI 연구');
console.log(carol.greet()); // "안녕하세요, Carol입니다. 저는 MIT 학생입니다. 대학원생입니다."
carol.research();           // "Carol이(가) "AI 연구" 주제로 연구하고 있습니다."

// instanceof로 상속 관계 확인
console.log(bob instanceof Student);  // true
console.log(bob instanceof Person);   // true
console.log(carol instanceof GraduateStudent); // true
console.log(carol instanceof Student);         // true
console.log(carol instanceof Person);          // true
                        </code></pre>
                        
                        <h3>프라이빗 필드와 메서드 (ES2022)</h3>
                        <p><strong>#</strong> 기호로 시작하는 필드와 메서드는 클래스 외부에서 접근할 수 없습니다.</p>
                        <pre><code class="language-javascript">
class BankAccount {
  // 프라이빗 필드
  #balance = 0;
  #accountNumber;
  
  // 정적 프라이빗 필드
  static #bankCode = 'KB001';
  
  constructor(initialBalance, accountNumber) {
    this.#balance = initialBalance;
    this.#accountNumber = accountNumber;
  }
  
  // 프라이빗 메서드
  #validateAmount(amount) {
    return amount > 0 && amount <= 1000000;
  }
  
  // 정적 프라이빗 메서드
  static #generateAccountNumber() {
    return Math.random().toString(36).substr(2, 9);
  }
  
  // 퍼블릭 메서드에서 프라이빗 멤버 사용
  deposit(amount) {
    if (this.#validateAmount(amount)) {
      this.#balance += amount;
      return true;
    }
    throw new Error('유효하지 않은 금액입니다.');
  }
  
  withdraw(amount) {
    if (this.#validateAmount(amount) && this.#balance >= amount) {
      this.#balance -= amount;
      return amount;
    }
    throw new Error('출금할 수 없습니다.');
  }
  
  get balance() {
    return this.#balance; // 읽기 전용 접근
  }
  
  get accountInfo() {
    return {
      accountNumber: this.#accountNumber,
      balance: this.#balance
    };
  }
  
  // 정적 메서드에서 정적 프라이빗 멤버 사용
  static createAccount(initialBalance) {
    const accountNumber = this.#generateAccountNumber();
    return new BankAccount(initialBalance, accountNumber);
  }
}

// 사용 예제
const account = BankAccount.createAccount(1000);
console.log(account.balance);           // 1000
account.deposit(500);                   // 성공
console.log(account.accountInfo);       // { accountNumber: '...', balance: 1500 }

// 프라이빗 필드는 외부에서 접근 불가
// console.log(account.#balance);       // SyntaxError
// account.#validateAmount(100);        // SyntaxError

// 상속에서도 프라이빗 필드는 접근 불가
class SavingsAccount extends BankAccount {
  calculateInterest() {
    // return this.#balance * 0.02; // 에러! 부모의 프라이빗 필드 접근 불가
    return this.balance * 0.02;      // getter 사용해야 함
  }
}
                        </code></pre>

                        <h3>클래스 사용 모범 사례</h3>
                        <ul>
                            <li><strong>캡슐화</strong>: 프라이빗 필드로 내부 상태 보호</li>
                            <li><strong>상속 계층</strong>: 너무 깊은 상속보다는 조합(composition) 선호</li>
                            <li><strong>인터페이스 일관성</strong>: 같은 역할의 클래스는 같은 메서드명 사용</li>
                            <li><strong>정적 메서드</strong>: 인스턴스와 무관한 유틸리티 기능에 활용</li>
                        </ul>
                    </div>
                </section>

                <!-- Slide 20: 20-data-structures 자료구조 -->
                <section class="slide" id="data-structures">
                    <div class="slide-content">
                        <h1>자료구조</h1>
                        <h3>Map</h3>
                        <p>키-값 쌍을 저장하는 컬렉션으로, 모든 타입의 값을 키로 사용할 수 있습니다.</p>
                        <pre><code class="language-javascript">
const map = new Map();

// 설정
map.set('name', 'Alice');
map.set(1, 'number key');
map.set(true, 'boolean key');

// 조회
console.log(map.get('name')); // 'Alice'
console.log(map.has('name')); // true
console.log(map.size); // 3

// 순회
for (const [key, value] of map) {
  console.log(key, value);
}

// 객체와의 차이점
const obj = {}; // 키는 문자열만 가능
const map2 = new Map(); // 모든 타입의 키 가능
                        </code></pre>
                        
                        <h3>Set</h3>
                        <p>중복되지 않는 값들의 컬렉션입니다.</p>
                        <pre><code class="language-javascript">
const set = new Set();

// 추가
set.add(1);
set.add(2);
set.add(2); // 중복은 무시됨

console.log(set.size); // 2
console.log(set.has(1)); // true

// 배열에서 중복 제거
const numbers = [1, 2, 2, 3, 3, 4];
const uniqueNumbers = [...new Set(numbers)];
console.log(uniqueNumbers); // [1, 2, 3, 4]

// 순회
for (const value of set) {
  console.log(value);
}
                        </code></pre>
                        
                        <h3>WeakMap과 WeakSet</h3>
                        <p>약한 참조를 사용하는 컬렉션으로, 키나 값이 가비지 컬렉션될 수 있습니다.</p>
                        <pre><code class="language-javascript">
// WeakMap: 객체만을 키로 사용 가능
const weakMap = new WeakMap();
let obj = { name: 'Alice' };

weakMap.set(obj, 'some value');
console.log(weakMap.get(obj)); // 'some value'

obj = null; // 객체 참조 제거 시 WeakMap에서도 자동으로 제거됨

// WeakSet: 객체만을 값으로 저장 가능
const weakSet = new WeakSet();
let obj1 = { id: 1 };
let obj2 = { id: 2 };

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 21: 21-async 비동기 프로그래밍 -->
                <section class="slide" id="async">
                    <div class="slide-content">
                        <h1>비동기 프로그래밍</h1>
                        <h3>동기 vs 비동기</h3>
                        <table>
                            <tr><th>방식</th><th>특징</th><th>예시</th></tr>
                            <tr>
                                <td><strong>동기 (Synchronous)</strong></td>
                                <td>코드가 순서대로 실행, 이전 작업 완료까지 대기</td>
                                <td>일반적인 함수 호출</td>
                            </tr>
                            <tr>
                                <td><strong>비동기 (Asynchronous)</strong></td>
                                <td>다른 작업을 기다리지 않고 다음 코드 실행</td>
                                <td>setTimeout, 네트워크 요청</td>
                            </tr>
                        </table>

                        <h3>호출 스택과 이벤트 루프</h3>
                        <p><strong>JavaScript는 단일 스레드</strong>이지만 비동기 작업을 처리할 수 있습니다.</p>
                        <pre><code class="language-javascript">
console.log('시작');

setTimeout(() => {
  console.log('타이머 완료');
}, 0);

console.log('끝');

// 출력 순서: '시작' → '끝' → '타이머 완료'
// 이유: setTimeout은 작업 큐로 이동하고, 호출 스택이 비워진 후 실행
                        </code></pre>

                        <h3>이벤트 루프 동작 방식</h3>
                        <ol>
                            <li><strong>호출 스택</strong>: 현재 실행 중인 함수들</li>
                            <li><strong>웹 API</strong>: 브라우저가 제공하는 비동기 기능 (setTimeout, DOM 이벤트 등)</li>
                            <li><strong>작업 큐</strong>: 완료된 비동기 작업의 콜백들</li>
                            <li><strong>이벤트 루프</strong>: 호출 스택이 비면 작업 큐에서 콜백을 가져와 실행</li>
                        </ol>

                        <h3>콜백 함수와 콜백 지옥</h3>
                        <p>비동기 작업이 완료되었을 때 호출되는 함수입니다.</p>
                        <pre><code class="language-javascript">
// 콜백 지옥 문제
getUserData(userId, (user) => {
  getOrderHistory(user.id, (orders) => {
    getOrderDetails(orders[0].id, (details) => {
      updateUI(details, (result) => {
        console.log('UI 업데이트 완료');
      });
    });
  });
});

// 문제점: 가독성 저하, 에러 처리 어려움, 유지보수 어려움
                        </code></pre>
                        
                        <h3>Promise 기본 개념</h3>
                        <p>Promise는 '언젠가 끝나는 작업'의 결과를 담는 객체입니다. 3가지 상태를 가집니다.</p>
                        <table>
                            <tr><th>상태</th><th>설명</th><th>전환</th></tr>
                            <tr><td><strong>Pending</strong></td><td>대기 중 (아직 완료되지 않음)</td><td>초기 상태</td></tr>
                            <tr><td><strong>Fulfilled</strong></td><td>성공적으로 완료됨</td><td>resolve() 호출</td></tr>
                            <tr><td><strong>Rejected</strong></td><td>실패함</td><td>reject() 호출</td></tr>
                        </table>

                        <h3>Promise 생성과 사용</h3>
                        <pre><code class="language-javascript">
// Promise 생성
function fetchUserData(userId) {
  return new Promise((resolve, reject) => {
    // 실제로는 API 호출이나 데이터베이스 쿼리 등
    setTimeout(() => {
      if (userId > 0) {
        resolve({ id: userId, name: '김개발', email: 'dev@example.com' });
      } else {
        reject(new Error('유효하지 않은 사용자 ID'));
      }
    }, 1000);
  });
}

// Promise 체이닝으로 콜백 지옥 해결
fetchUserData(1)
  .then(user => {
    console.log('사용자 정보:', user);
    return fetch(`/api/orders/${user.id}`); // 다른 비동기 작업
  })
  .then(response => response.json())
  .then(orders => {
    console.log('주문 내역:', orders);
  })
  .catch(error => {
    console.error('에러 발생:', error.message);
  })
  .finally(() => {
    console.log('작업 완료 (성공/실패 무관)');
  });
                        </code></pre>
                        
                        <h3>async/await - Promise를 동기식 코드처럼</h3>
                        <p>Promise를 더 읽기 쉬운 형태로 작성할 수 있게 해주는 ES2017 문법입니다.</p>
                        <pre><code class="language-javascript">
// Promise 체이닝 방식 (읽기 어려움)
function processUserWithPromises(userId) {
  return fetchUserData(userId)
    .then(user => {
      return getOrderHistory(user.id);
    })
    .then(orders => {
      return calculateTotal(orders);
    })
    .catch(error => {
      console.error('에러:', error);
    });
}

// async/await 방식 (동기식 코드처럼 읽기 쉬움)
async function processUserWithAsync(userId) {
  try {
    const user = await fetchUserData(userId);
    const orders = await getOrderHistory(user.id);
    const total = await calculateTotal(orders);
    
    return { user, orders, total };
  } catch (error) {
    console.error('에러 발생:', error.message);
    throw error; // 에러를 다시 던져서 호출자에게 전달
  }
}

// 사용법
async function main() {
  try {
    const result = await processUserWithAsync(1);
    console.log('처리 결과:', result);
  } catch (error) {
    console.log('최종 에러 처리:', error.message);
  }
}

main();
                        </code></pre>
                        
                        <h3>Promise 유틸리티 메서드</h3>
                        <table>
                            <tr><th>메서드</th><th>동작</th><th>실패 조건</th></tr>
                            <tr><td><strong>Promise.all</strong></td><td>모든 Promise 완료 대기</td><td>하나라도 실패하면 즉시 실패</td></tr>
                            <tr><td><strong>Promise.allSettled</strong></td><td>모든 Promise 완료 대기</td><td>실패하지 않음 (성공/실패 상태 모두 반환)</td></tr>
                            <tr><td><strong>Promise.race</strong></td><td>가장 먼저 완료되는 것</td><td>가장 먼저 실패하는 것</td></tr>
                            <tr><td><strong>Promise.any</strong></td><td>가장 먼저 성공하는 것</td><td>모든 Promise가 실패</td></tr>
                        </table>

                        <h3>실제 사용 예제</h3>
                        <pre><code class="language-javascript">
// 여러 API에서 동시에 데이터 가져오기
async function fetchDashboardData() {
  try {
    // 모든 요청을 병렬로 처리 (시간 단축)
    const [userData, ordersData, analyticsData] = await Promise.all([
      fetch('/api/user').then(r => r.json()),
      fetch('/api/orders').then(r => r.json()),
      fetch('/api/analytics').then(r => r.json())
    ]);
    
    return { userData, ordersData, analyticsData };
  } catch (error) {
    console.error('대시보드 데이터 로딩 실패:', error);
    throw error;
  }
}

// 여러 서버 중 가장 빠른 응답 사용 (로드 밸런싱)
async function getFastestResponse() {
  const servers = [
    'https://api1.example.com/data',
    'https://api2.example.com/data', 
    'https://api3.example.com/data'
  ];
  
  try {
    const response = await Promise.race(
      servers.map(url => fetch(url))
    );
    return await response.json();
  } catch (error) {
    console.error('모든 서버 응답 실패:', error);
  }
}

// 부분적 실패를 허용하는 데이터 수집
async function collectOptionalData() {
  const promises = [
    fetchUserData(),
    fetchOrderHistory(),
    fetchRecommendations() // 실패해도 괜찮은 부가 정보
  ];
  
  const results = await Promise.allSettled(promises);
  
  const data = {};
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      const keys = ['user', 'orders', 'recommendations'];
      data[keys[index]] = result.value;
    }
  });
  
  return data; // 성공한 데이터만 포함
}
                        </code></pre>

                        <h3>비동기 프로그래밍 모범 사례</h3>
                        <ul>
                            <li><strong>항상 에러 처리</strong>: try/catch 또는 .catch() 사용</li>
                            <li><strong>병렬 처리 활용</strong>: 독립적인 비동기 작업은 Promise.all 사용</li>
                            <li><strong>성능 고려</strong>: 불필요한 await 체인보다는 병렬 처리</li>
                            <li><strong>사용자 경험</strong>: 로딩 상태와 에러 상태 UI 제공</li>
                        </ul>
                    </div>
                </section>

                <!-- Slide 22: 22-exception 예외 처리 -->
                <section class="slide" id="exception">
                    <div class="slide-content">
                        <h1>예외 처리</h1>
                        
                        <h3>예외 처리의 필요성</h3>
                        <p>코드 실행 중 발생할 수 있는 다양한 에러로부터 프로그램의 실행 흐름을 복구합니다.</p>
                        <ul>
                            <li><strong>RangeError</strong>: 잘못된 범위 값 (예: <code>new Array(-1)</code>)</li>
                            <li><strong>ReferenceError</strong>: 존재하지 않는 변수 참조</li>
                            <li><strong>TypeError</strong>: 잘못된 타입 사용</li>
                            <li><strong>네트워크 에러</strong>: 외부 요인으로 인한 실패</li>
                        </ul>

                        <h3>try...catch...finally 구문</h3>
                        <p>에러가 발생해도 코드 실행을 지속할 수 있는 JavaScript의 핵심 예외 처리 메커니즘입니다.</p>
                        <pre><code class="language-javascript">
try {
  console.log('에러가 나기 직전까지는 정상 실행됩니다.');
  new Array(-1);          // RangeError: Invalid array length
  console.log('이 코드는 실행되지 않습니다.');
} catch (e) {
  console.log('코드 실행 흐름이 catch 블록으로 이동합니다.');
  console.log(`에러 정보: ${e.name} - ${e.message}`);
} finally {
  console.log('finally는 에러 발생 여부와 관계없이 항상 실행됩니다.');
}

// 에러 객체가 필요 없는 경우 생략 가능 (ES2019)
try {
  riskyOperation();
} catch {
  console.log('에러가 발생했습니다.');
}
                        </code></pre>

                        <h3>실행 순서와 finally의 특성</h3>
                        <pre><code class="language-javascript">
// finally는 return, break, continue가 있어도 실행됨
function testFinally() {
  try {
    console.log('try 블록');
    return 'try에서 반환'; // 이 시점에서 함수가 종료되지만...
  } finally {
    console.log('finally 블록'); // 이것은 여전히 실행됨
  }
}

testFinally(); 
// 출력: "try 블록", "finally 블록"
// 반환: "try에서 반환"

// 루프에서도 마찬가지
for (let i of [1, 2, 3]) {
  try {
    if (i === 2) break;
    console.log(`현재 i: ${i}`);
  } finally {
    console.log(`finally에서 i: ${i}`); // break 후에도 실행
  }
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 22-2: 에러 생성과 커스텀 에러 -->
                <section class="slide" id="error-creation">
                    <div class="slide-content">
                        <h1>에러 생성과 커스텀 에러</h1>
                        
                        <h3>직접 에러 발생시키기</h3>
                        <p><code>throw</code> 구문과 <code>Error</code> 생성자를 사용해 의도적으로 에러를 발생시킬 수 있습니다.</p>
                        <pre><code class="language-javascript">
function validateEvenNumber(num) {
  const parsed = parseInt(num);
  
  if (isNaN(parsed)) {
    throw new Error('숫자가 아닙니다.');
  }
  
  if (parsed % 2 !== 0) {
    throw new Error('짝수가 아닙니다.');
  }
  
  return parsed;
}

try {
  const result = validateEvenNumber('7');
  console.log('입력된 짝수:', result);
} catch (e) {
  console.error('검증 실패:', e.message);
}
                        </code></pre>

                        <h3>커스텀 에러 클래스</h3>
                        <p>에러의 종류를 구분하거나 추가 정보를 포함하기 위해 <code>Error</code>를 상속하는 클래스를 만들 수 있습니다.</p>
                        <pre><code class="language-javascript">
// 커스텀 에러 클래스 정의
class ValidationError extends Error {
  constructor(value, message) {
    super(message);
    this.name = 'ValidationError';
    this.value = value;      // 에러를 발생시킨 값
  }
}

class NetworkError extends Error {
  constructor(statusCode, message) {
    super(message);
    this.name = 'NetworkError';
    this.statusCode = statusCode;
  }
}

// 사용 예제
function processUserInput(input) {
  try {
    const num = parseInt(input);
    if (isNaN(num)) {
      throw new ValidationError(input, '유효한 숫자가 아닙니다.');
    }
    if (num < 0) {
      throw new ValidationError(num, '음수는 허용되지 않습니다.');
    }
    return num * 2;
  } catch (e) {
    if (e instanceof ValidationError) {
      console.log(`입력값 ${e.value}에 대한 검증 오류: ${e.message}`);
      return null;
    } else {
      throw e; // 다른 종류의 에러는 다시 던지기
    }
  }
}

console.log(processUserInput('abc'));  // 검증 오류 처리
console.log(processUserInput('-5'));   // 검증 오류 처리  
console.log(processUserInput('10'));   // 20 반환
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 22-3: 비동기 코드에서의 예외 처리 -->
                <section class="slide" id="async-exception">
                    <div class="slide-content">
                        <h1>비동기 코드에서의 예외 처리</h1>
                        
                        <h3>비동기 콜백에서의 예외 처리</h3>
                        <p><strong>비동기 콜백 내부</strong>의 에러는 외부 <code>try...catch</code>로 잡을 수 없습니다.</p>
                        <pre><code class="language-javascript">
// ❌ 잘못된 방법 - 외부 try...catch는 비동기 에러를 잡지 못함
try {
  setTimeout(() => {
    throw new Error('비동기 에러!');
  }, 1000);
} catch (e) {
  console.log('이 코드는 실행되지 않습니다.'); // 에러를 잡지 못함
}

// ✅ 올바른 방법 - 비동기 콜백 내부에 try...catch 배치
setTimeout(() => {
  try {
    throw new Error('비동기 에러!');
  } catch (e) {
    console.log('비동기 에러 처리:', e.message); // 정상 처리됨
  }
}, 1000);
                        </code></pre>

                        <h3>Promise에서의 예외 처리</h3>
                        <p>Promise는 <strong>rejected 상태</strong>를 통해 에러를 처리합니다.</p>
                        <pre><code class="language-javascript">
// Promise에서 에러 발생 시 rejected 상태가 됨
const riskPromise = new Promise((resolve, reject) => {
  const input = parseInt(prompt('짝수를 입력하세요'));
  if (input % 2 !== 0) {
    reject(new Error('짝수가 아닙니다.'));
  } else {
    resolve(input);
  }
});

// 방법 1: then의 두 번째 인수로 에러 처리
riskPromise.then(
  value => console.log('성공:', value),
  error => console.log('실패:', error.message)
);

// 방법 2: catch 메소드 사용 (더 권장)
riskPromise
  .then(value => {
    console.log('성공:', value);
    return value * 2;
  })
  .catch(error => {
    console.log('에러 처리:', error.message);
    return 0; // 기본값 반환
  })
  .then(result => console.log('최종 결과:', result));

// Promise 체인에서 에러는 처음 만나는 catch로 점프
Promise.resolve(10)
  .then(x => {
    throw new Error('중간에 에러 발생');
    return x * 2; // 실행되지 않음
  })
  .then(x => {
    console.log('이 코드도 실행되지 않음');
    return x + 1;
  })
  .catch(e => {
    console.log('에러 포착:', e.message);
    return 'recovered'; // 복구된 값
  })
  .then(result => console.log('복구 후:', result)); // 'recovered'
                        </code></pre>

                        <h3>async/await에서의 예외 처리</h3>
                        <p><strong>비동기 함수</strong>에서는 Promise의 rejected 상태를 일반적인 <code>try...catch</code>로 처리할 수 있습니다.</p>
                        <pre><code class="language-javascript">
async function fetchUserData(userId) {
  try {
    // await는 Promise가 rejected되면 예외를 던짐
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const userData = await response.json();
    console.log('사용자 데이터:', userData);
    return userData;
    
  } catch (error) {
    console.error('데이터 가져오기 실패:', error.message);
    
    // 에러 타입에 따른 다른 처리
    if (error.name === 'TypeError') {
      console.log('네트워크 연결을 확인하세요.');
    }
    
    throw error; // 호출자에게 에러 전파
  } finally {
    console.log('API 호출 시도 완료');
  }
}

// ⚠️ 주의: await 없이 Promise를 사용하면 catch 블록이 실행되지 않음
async function incorrectUsage() {
  try {
    fetch('https://nonexistent-domain.nowhere'); // await 없음!
  } catch (e) {
    console.log('이 코드는 실행되지 않습니다.');
  }
}

// ✅ 올바른 사용법
async function correctUsage() {
  try {
    await fetch('https://nonexistent-domain.nowhere'); // await 사용
  } catch (e) {
    console.log('네트워크 에러 처리:', e.message);
  }
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 23: 23-module 모듈 시스템 -->
                <section class="slide" id="module-system">
                    <div class="slide-content">
                        <h1>모듈 시스템 (ES2015)</h1>
                        <p>코드를 여러 파일로 분리하여 재사용성과 유지보수성을 높이는 시스템입니다.</p>
                        
                        <h3>export (내보내기)</h3>
                        <p>다른 파일에서 사용할 변수, 함수, 클래스를 지정합니다.</p>
                        <pre><code class="language-javascript">
// math.js

// 이름 지정 내보내기 (Named Export)
export const PI = 3.14;
export function add(a, b) {
  return a + b;
}

// 기본 내보내기 (Default Export, 파일당 하나만 가능)
export default class Calculator {
  // ...
}
                        </code></pre>

                        <h3>import (가져오기)</h3>
                        <p>다른 모듈에서 내보낸 기능들을 현재 파일로 가져옵니다.</p>
                        <pre><code class="language-javascript">
// main.js

// 이름 지정 가져오기 (중괄호 사용)
import { PI, add } from './math.js';

// 기본 가져오기 (원하는 이름으로)
import MyCalculator from './math.js';

// 전체 가져오기
import * as math from './math.js';
console.log(math.PI);
                        </code></pre>

                        <h3>모듈의 특징</h3>
                        <ul>
                            <li><strong>모듈 스코프:</strong> 모듈 내 최상위 변수는 전역 변수가 아닙니다.</li>
                            <li><strong>엄격 모드(Strict Mode):</strong> 자동으로 활성화됩니다.</li>
                            <li><strong>단 한 번만 실행:</strong> 같은 모듈을 여러 번 <code>import</code>해도 코드는 한 번만 실행됩니다.</li>
                        </ul>
                    </div>
                </section>

                <!-- Slide 24: 24-misc 기타 -->
                <section class="slide" id="misc">
                    <div class="slide-content">
                        <h1>기타 유용한 기능들</h1>
                        <h3>구조 분해 할당 (Destructuring)</h3>
                        <pre><code class="language-javascript">
// 배열 구조 분해
const [a, b, c] = [1, 2, 3];
console.log(a, b, c); // 1 2 3

// 객체 구조 분해
const { name, age } = { name: 'Alice', age: 30, city: 'Seoul' };
console.log(name, age); // 'Alice' 30

// 함수 매개변수에서 구조 분해
function greet({ name, age }) {
  console.log(`안녕하세요, ${name}님! ${age}세이시군요.`);
}

greet({ name: 'Bob', age: 25 });
                        </code></pre>
                        
                        <h3>스프레드 연산자 (...)</h3>
                        <pre><code class="language-javascript">
// 배열 스프레드
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// 객체 스프레드
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }

// 함수 호출에서 스프레드
const numbers = [1, 2, 3];
console.log(Math.max(...numbers)); // 3
                        </code></pre>
                        
                        <h3>정규 표현식 (Regular Expression)</h3>
                        <pre><code class="language-javascript">
// 정규식 생성
const regex1 = /hello/i; // 리터럴 방식
const regex2 = new RegExp('hello', 'i'); // 생성자 방식

// 문자열 메서드와 함께 사용
const text = 'Hello, World!';
console.log(text.match(/[A-Z]/g)); // ['H', 'W'] (대문자 찾기)
console.log(text.replace(/Hello/, 'Hi')); // 'Hi, World!'

// 이메일 유효성 검사
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
console.log(emailRegex.test('user@example.com')); // true
                        </code></pre>
                        
                        <h3>JSON 처리</h3>
                        <pre><code class="language-javascript">
// 객체를 JSON 문자열로 변환
const obj = { name: 'Alice', age: 30 };
const jsonString = JSON.stringify(obj);
console.log(jsonString); // '{"name":"Alice","age":30}'

// JSON 문자열을 객체로 변환
const parsed = JSON.parse(jsonString);
console.log(parsed); // { name: 'Alice', age: 30 }

// 깊은 복사에 활용 (단, 함수, undefined, Symbol은 제외됨)
const deepCopy = JSON.parse(JSON.stringify(obj));
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 25: Final -->
                <section class="slide title-slide" id="final">
                    <div class="slide-content">
                        <h1>학습을 마치며</h1>
                        <h2>꾸준함이 최고의 실력입니다.</h2>
                        <p style="margin-top: 50px;">지금까지 JavaScript의 핵심 개념들을 살펴보았습니다.<br>이제 실제 프로젝트에 적용하며 깊이를 더해보세요!</p>
                    </div>
                </section>
                
            </div>
            <div id="progress-bar">
                <div id="progress-indicator"></div>
            </div>
        </main>
    </div>

    <div id="controls">
        <button id="prev-btn">이전</button>
        <button id="next-btn">다음</button>
    </div>

    <script src="script.js"></script>
</body>
</html>